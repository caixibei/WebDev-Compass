Zuul 服务网关

## 学习目标

![image-20251211141511205](assets/image-20251211141511205.png)

## 什么是 Zuul

Zuul 是从设备和网站到应用程序后端的所有请求的前门。作为边缘服务应用程序，Zuul 旨在实现动态路由，监视，弹性和安全性。Zuul 包含了对请求的路由和过滤两个最主要的功能。

Zuul 是 Netflix 开源的微服务网关，它可以和 Eureka、Ribbon 、Hystrix 等组件配合使用。Zuul 的核心是一系列的过滤器，这些过滤器可以完成以下功能：

- 身份认证与安全：识别每个资源的验证要求，并拒绝那些与要求不符的请求；
- 审查与监控：在边缘位置追踪有意义的数据和统计结果，从而带来精确的生产试图；
- 动态路由：动态的将请求路由到不同的后端集群；
- 压力测试：逐渐增加指向集群的流量，以了解性能；
- 负载分配：为每一种负载类型分配对应容量，并弃用超出限定值的请求；
- 静态响应处理：在边缘位置直接建立部分响应，从而避免转发到内部集群；
- 多区域弹性：跨越 AWS Region 进行请求路由，旨在实现 ELB 使用的多样化，以及让系统的边缘更贴近系统的使用者；

## 什么是服务网关

API Gateway （APIGW / API 网关），故名思义，是出现在系统边界山歌的一个面向 API 的、串行集中式的强管控服务，这里的边界是企业 IT 系统的边界，可以理解为企业级应用防火墙，主要起到隔离外部访问与内部系统的作用。在微服务概念的流行之前，API 网关就已经诞生了，例如银行、证券等领域常见的前置机系统，也是解决访问认证、报文转换、访问统计等问题的。

API 网关的流行，源于近几年来移动应用与企业间互联网需求的兴起。移动应用、企业互联，使得后台服务支持的对象，从以前单一的 Web 应用，扩展到多种应用场景，且每种使用场景对后台服务的要求都不尽相同。这不仅增加了后台服务的响应量，还增加了后台服务的复杂性。随着微服务架构概念的提出，API 网关成为了微服务架构的一个标配组件。

API 网关是一个服务器，是系统对外的唯一入口。API 网关封装了系统内部架构，为每个客户端提供定制的 API 。所有的客户端和消费端都通过统一的网关接入微服务，在网关层处理所有的非业务功能。API 网关并不是微服务场景中必须的组件，如下图，不管有没有 API 网关，后端微服务都可以通过 API 很好的支持客户端的访问。

<img src="assets/image-20251220154549792.png" alt="image-20251220154549792" style="zoom:67%;" />

但对于服务数量众多，复杂度较高，规模比较大的业务来说，引入 API 网关也有一系列的好处：

- 聚合接口使得服务对调用者透明，客户端与后端的耦合度降低；
- 聚合后台服务，节省流量，提高性能，以提升用户体验；
- 提供安全、流控、过滤、缓存、计费、监控等 API 管理功能；

## 为什么要使用网关

Zuul 是 Netflix 开源的 API 网关，本质是一个 **反向代理 + 过滤器链** 的架构模式。它在不同架构中的价值体现有显著差异。

- 单体应用：浏览器发起请求到单体应用所在的机器，应用从数据库查询数据原路返回给浏览器，对于单体应用来说是不需要网关的。
- 微服务：微服务的应用可能部署在不同机房，不同地区，不同域名下。此时客户端（浏览器/手机/软件工具）想要请求对应的服务，都需要知道机器的具体 IP 地址 或者域名 URL，当微服务实例众多的时候，这是十分难以记忆的，对于客户端来说也太复杂难以维护。此时就有了网关，客户端相关的请求直接发送到网关，由网关根据请求标识解析判断出具体的微服务地址，再把请求转发到微服务实例。这其中的记忆功能就全部交给网关去操作了。

<img src="assets/image-20251220164718340.png" alt="image-20251220164718340" style="zoom:67%;" />



总的来说，如果让客户端直接与各微服务交互，会带来以下问题：

- 客户端会多次请求不同的微服务，增加了客户端的复杂性；
- 存在跨域请求问题，且在某些场景下处理相对复杂；
- 身份认证问题，每个微服务都需要独立的身份认证；
- 难以重构，随着项目的迭代，可能需要重新划分微服务；
- 某些微服务可能使用了防火墙/浏览器不友好的协议，直接访问存在一定的困难；

因此，为了解决这些问题，我们需要网关介于客户端与服务器之间的中间层，所有的外部请求率先经过微服务网关，客户端只需要与网关进行交互，只需要网关地址即可，这样便简化了开发且有以下优点。

- 易于监控，可在微服务网关收集监控数据并将其推送到外部系统进行分析；
- 易于认证，可在微服务网关上进行认证，然后再将请求转发到后端的微服务，从而无需在每个微服务中进行认证；
- 减少了客户端与各微服务之间的交互次数；

## 网关解决了什么问题

<img src="assets/image-20251220172914409.png" alt="image-20251220172914409" style="zoom:67%;" />

网关具有身份认证与安全、审查与监控、动态路由、负载均衡、缓存、请求分片与管理、静态响应处理等功能。当然最主要的职责还是 “与外界联系”。

总结来说，网关应该具有以下功能：

- 性能：API 高可用，负载均衡，容错机制；
- 安全：权限身份认证、脱敏、流量清洗、后端签名（保证全链路可信调用）、黑名单（非法调用限制）；
- 日志：日志记录，一旦设计分布式，全链路跟踪必不可少；
- 缓存：数据缓存；
- 监控：记录请求响应数据，API 耗时分析，性能监控；
- 限流：流量控制、错峰流控，可以定义多种限流规则；
- 灰度：线上灰度部署，可以减少风险；
- 路由：动态路由规则；

## 常用网关解决方案

### Nginx + Lua脚本

Nginx 是由 IgorSysoev 为俄罗斯访问量第二的 Rmbler.ru 站点开发的，一个高性能的 HTTP 和反向代理服务器，一方面可以做反向代理，另一方面可以做静态资源服务器。

🎯 Nginx 和 Zuul 有以下几个区别：

- Nginx 是 C 语言开发的，而 Zuul 是 Java 语言开发；
- Nginx 负载均衡实现是采用服务器实现负载均衡，而 Zuul 负载均衡的实现采用 Ribbon + Eureka 来实现本地负载均衡；
- Nginx 适合于服务器端负载均衡，Zuul 适合微服务中实现网关；
- Nginx 相比于 Zuul 功能会更加强大，因为 Nginx 可以整合一些脚本语言（Nginx + Lua 脚本）；
- Nginx 是一个高性能的 HTTP 和反向代理服务器，也是一个 IMAP / POP3 / SMIP 服务器。Zuul 是 Spring Cloud Netflix 中的开源的一个 API Gateway 服务器，本质上是一个 Servlet 应用，提供了动态路由、监控、弹性、安全等边缘服务的框架。Zuul 相当于是从设备到网站应用程序后端的所有请求的前门。

-   Nginx 适合做门户网关，是作为整个全局的网关，对外的处于最外层的那种；而 Zuul 属于业务网关，主要用来对应不同的客户端提供服务，用于聚合业务。各微服务独立部署，职责单一，对外提供服务的时候需要有一个东西将业务聚合起来；
-   Zuul 可以实现熔断、重试等功能，这是 Nginx 不具备的。

### Kong

Kong 是 Mashape 提供的一款 API 管理软件，本身是基于 Nginx + Lua 的，但比 Nginx 提供了更为简单的配置方式，数据采用了 ApacheCassandra / PostgreSQL 存储，并且提供了一些优秀的插件，比如验证，日志，调用频次限制等。Kong 非常诱人的地方就是提供了大量的插件来扩展应用，通过设置不同的插件可以为服务提供各种增强的功能。

🎯 具备以下优缺点：

-   优点：基于 Nginx 所以在性能和稳定性方面不会有问题。Kong 作为一款商业软件，在 Nginx 上做了很多的扩展性工作，并且还有很多付费使用的商业插件。Kong 本身也有付费的企业版，其中包括技术支持、使用培训服务以及 API 分析插件。
-   缺点：如果你使用 Spring Cloud , Kong 如何结合目前已有的服务治理体系？

### Traefik

Traefik 是一个开源的 Go 语言开发的，为了让微服务部署更加便捷而诞生的现代 HTTP 反向代理、负载均衡工具。它支持多种后台（Docker、Swarm、Kubernates、Marathon、Mesos、Consul、Etcd、Zookeeper、BoltDB、Rest API 等）来自动化、动态的应用他的配置文件设置，Traefik 拥有一个基于 AngularJS 编写的简单网站界面，支持 RestAPI，配置文件热更新，无需重启进程。高可用集群模式等。

🎯 相比 Spring Cloud 和 Kubernetes 而言，目前比较适合 Kubernetes 。

### SpringCloud Netflix Zuul

Zuul 是Netflix 公司开源的一个 API 网关组件，Spring Cloud 对其进行二次基于 Spring Boot 的注解式封装做到开箱即用。目前来说，结合 Spring Cloud 提供的服务治理体系，可以做到请求转发，根据配置或者默认的路由规则进行路由和负载均衡，无缝集成 Hystrix 。

虽然可以通过自定义 Filter 过滤器实现我们想要的功能，但是由于 Zuul 本身的涉及是基于 单线程的接收请求和转发处理，是阻塞 IO，不支持长连接。目前来看 Zuul 就显得很鸡肋，随着 Zuul 2.x 版本一致跳票 （2019年5月发布了 Zuul 2.0 版本），Spring Cloud 为了保险起见，推出了自己的 Spring Cloud Gateway。

<span style="color:darkgrey;font-size:12px;">大意就是：Zuul 已死，Spring Cloud Gateway 永生！🐶</span>

#### Zuul 1.0

<img src="./assets/image-20241210234005117.png" alt="架构图" style="zoom: 67%;" />

<img src="./assets/image-20241210234107613.png" alt="核心类图" style="zoom: 67%;" />

<img src="./assets/image-20241210234215051.png" alt="模型" style="zoom:95%;" />

#### Zuul 2.0

![image-20241210234349976](./assets/image-20241210234349976.png)

### SpringCloud Gateway

Spring Cloud Gateway 的工作原理：

![image-20241210234610441](./assets/image-20241210234610441.png)

客户端向 Spring Cloud Gateway 发出请求。如果网关处理程序映射确定请求与路由匹配，则会将其发送到网关 Web 处理程序。此处理程序通过特定于请求的筛选条件链运行请求。过滤器被虚线划分的原因是 filter 可以在发送代理请求之前和之后运行 logic。执行所有 “pre” filter logic。然后发出代理请求。发出代理请求后，将运行 “post” 筛选条件逻辑。

## Zuul 环境准备

我们新建一个微服务的项目，项目结构大致如下图所示。

![image-20251220195034652](assets/image-20251220195034652.png)

- Eureka 注册中心：提供服务发现和注册功能；
- Zuul 网关：提供动态路由功能；
- 模块 A：测试服务；
- 模块 B：测试服务；

![image-20251220232439113](assets/image-20251220232439113.png)

## Nginx 实现 API 网关

<img src="assets/image-20251221004038830.png" alt="image-20251221004038830" style="zoom: 35%;" />

在之前的课程中我们已经详细的讲解了 Nginx 关于反向代理、负载均衡等功能的使用，这里不再赘述。主要通过 Nginx 来实现 API 网关方便大家更好的学习和理解 Zuul 的使用。

### 下载安装

在这之前我们需要前往 [https://nginx.org/en/download.html](https://nginx.org/en/download.html) 下载 Nginx 服务器软件：

![image-20241211154334985](./assets/image-20241211154334985.png)

下载完成后解压到指定路径下 <span style="color:#ff6e00;">（不要放中文路径下！！！）</span>：

<img src="./assets/image-20241211154456228.png" alt="image-20241211154456228" style="zoom:95%;" />

双击启动  `nginx.exe`  程序，然后访问 [http://127.0.0.1:80/](http://127.0.0.1:80/) ，如果启动成功，页面如下所示：

![image-20241211154724058](./assets/image-20241211154724058.png)

打开配置文件  `conf\nginx.conf`  ，默认配置如下：

```bash
worker_processes  1;
events {
    worker_connections  1024;
}
http {
    include       mime.types;
    default_type  application/octet-stream;
    sendfile        on;
    keepalive_timeout  65;
    server {
    	# 监听端口 80
        listen       80;
        server_name  localhost;
        
        # 资源路径
        location / {
            root   html;
            index  index.html index.htm;
        }
        
        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   html;
        }
    }
}
```

### 配置路由规则

```bash
worker_processes  1;
events {
    worker_connections  1024;
}
http {
    include       mime.types;
    default_type  application/octet-stream;
    sendfile        on;
    keepalive_timeout  65;
    server {
    	# 监听端口 80
        listen       80;
        server_name  localhost;
        
        # 资源路径
        location / {
            root   html;
            index  index.html index.htm;
        }
        
        # 路由到 autumnnook-system 模块
        location /system/ {
        	proxy_pass http://127.0.0.1:18080/;
        }

        # 路由到 autumnnook-menu 模块
        location /menu/ {
        	proxy_pass http://127.0.0.1:18081/;
        }
        
        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   html;
        }
    }
}
```

我们来看下 Eureka 中注册的服务列表，当我们访问  `/system`  的时候，就将它路由到  `http://127.0.0.1/18080/` 。同样的，当我们访问  `/menu` 的时候，路由到  `http://127.0.0.1:18081/` 。

![image-20251221003503166](assets/image-20251221003503166.png)

在任务管理器中关闭 Nginx 进程后再次重启，以让配置文件生效后，访问 http://127.0.0.1/system/test/info ，如下所示，成功访问 system 模块的服务，说明路由转发成功了。

![image-20251221003834009](assets/image-20251221003834009.png)



## Zuul 实现 API 网关入门案例

### 搭建网关服务

#### 创建项目

创建 `autumnnook-zuul  `项目模块

![image-20251221005040072](assets/image-20251221005040072.png)

#### 添加项目依赖

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-zuul</artifactId>
</dependency>
<!--...其他依赖配置不做展示-->
```

#### 配置文件

```yaml
# Zuul 网关应用配置文件
#
# 该配置文件定义了 Zuul API 网关的核心配置，包括服务器设置、Spring 应用配置、
# Zuul 网关特性和 Eureka 服务发现配置。
#
# 主要功能：
# - 配置网关服务器参数和性能优化
# - 定义 Zuul 路由和负载均衡行为
# - 配置服务注册与发现（Eureka）
# - 设置健康检查和监控端点
#
# 适用场景：
# - 微服务架构中的 API 网关
# - 服务路由和负载均衡
# - 请求过滤和权限控制
# - 服务注册发现和健康监控
server:
  # 服务器端口配置
  port: ${SERVER_PORT:30000}
  # Undertow 服务器性能优化配置
  # Undertow 是高性能的 NIO 服务器，适用于高并发场景
  undertow:
    # I/O 线程数，负责处理非阻塞 I/O 操作
    # 建议设置为 CPU 核心数的 1-2 倍
    io-threads: 16
    # 工作线程数，负责处理业务逻辑
    # 根据业务复杂度和并发量调整，通常设置为 I/O 线程数的 10-100 倍
    worker-threads: 1600
    # 是否使用直接内存缓冲区
    # true 表示使用堆外内存，减少 GC 压力，提高性能
    direct-buffers: true
  # Servlet 上下文路径配置
  # 定义应用访问的基础路径，所有请求都需要包含此路径
  servlet:
    context-path: /
spring:
  # 应用名称配置，用于服务注册和发现
  # 在 Eureka 中以此名称注册服务
  application:
    name: ${APPLICATION_NAME:autumnnook-zuul}
  # Spring MVC 配置
  mvc:
    # 当没有找到请求处理器时是否抛出异常
    # true: 抛出 NoHandlerFoundException，便于统一异常处理
    # false: 返回默认 404 页面
    throw-exception-if-no-handler-found: true
  # 静态资源映射配置
  resources:
    # 是否启用静态资源映射
    # true: 启用，可以访问静态资源文件
    # false: 禁用，适用于纯 API 网关场景
    add-mappings: false
# Zuul 网关核心配置
zuul:
  # 信号量配置，用于控制并发请求数量
  semaphore:
    # 最大信号量数量，限制同时处理的请求数
    # 防止网关被过多请求压垮，起到熔断保护作用
    max-semaphores: 1100
  # 敏感请求头配置
  # 空数组表示不过滤任何请求头，所有头信息都会转发到下游服务
  sensitive-headers:
  # 是否剥离路由前缀
  # false: 保留完整路径转发到下游服务
  # true: 去除路由匹配的前缀部分
  strip-prefix: false
  # 是否添加 Host 头信息
  # true: 在转发请求时添加 Host 头，便于下游服务识别请求来源
  add-host-header: true
  # HTTP 客户端连接池配置
  host:
    # 最大总连接数，限制网关与所有下游服务的总连接数
    maxTotalConnections: 10000
    # 每个路由的最大连接数，限制到单个服务的最大连接数
    maxPerRouteConnections: 1100
    # Socket 超时时间（毫秒）
    # 设置与下游服务建立连接的超时时间
    socket-timeout-millis: 3600000
  # 是否忽略安全相关的响应头
  # false: 保留安全头信息（如 X-Content-Type-Options 等）
  ignoreSecurityHeaders: false
# Eureka 客户端配置
# 用于服务注册发现，网关需要注册到 Eureka 并发现其他服务
eureka:
  # 实例配置，定义当前服务实例的注册信息
  instance:
    # 实例主机名，用于服务发现时的地址解析
    hostname: ${HOSTNAME:${spring.application.name}}
    # 是否优先使用 IP 地址进行注册
    # false: 使用主机名注册
    # true: 使用 IP 地址注册，适用于容器化部署
    prefer-ip-address: ${PREFER_IP_ADDRESS:false}
    # 实例 ID 格式，在 Eureka 服务器中唯一标识此实例
    instance-id: ${spring.application.name}:${HOSTNAME:localhost}:${server.port}
    # 心跳续约间隔（秒）
    # 客户端向 Eureka 服务器发送心跳的频率
    lease-renewal-interval-in-seconds: ${LEASE_RENEWAL_INTERVAL_IN_SECONDS:10}
    # 租约过期时间（秒）
    # Eureka 服务器在多久没有收到心跳后认为实例下线
    lease-expiration-duration-in-seconds: 30
    # 状态页面 URL，用于展示实例状态信息
    status-page-url: http://${HOSTNAME:localhost}:${server.port}/actuator/info
    # 健康检查 URL，Eureka 服务器定期检查实例健康状态
    health-check-url: http://${HOSTNAME:localhost}:${server.port}/actuator/health
    # 主页 URL，实例的主页地址
    home-page-url: http://${HOSTNAME:localhost}:${server.port}
  # Eureka 客户端行为配置
  client:
    # 是否启用健康检查
    healthcheck:
      enabled: true
    # 是否从 Eureka 服务器获取注册表信息
    # true: 获取其他服务注册信息，用于服务发现
    fetch-registry: ${FETCH_REGISTRY:true}
    # 是否注册到 Eureka 服务器
    # true: 将本实例注册到 Eureka，供其他服务发现
    register-with-eureka: ${REGISTER_WITH_EUREKA:true}
    # Eureka 服务器地址配置
    service-url:
      # Eureka 服务器集群地址，支持多个地址用逗号分隔
      # 格式：协议://用户名:密码@主机名:端口/eureka/
      defaultZone: ${EUREKA_PEERS:http://soaadmin:jsepc01!@autumnnook-eureka:8761/eureka/}
```

#### 启动类

启动类需要添加 `@EnableZuulProxy` 注解（其余注解配置可以忽视，展示出来的比较全）

```java
package com.autumnnook;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.client.discovery.EnableDiscoveryClient;
import org.springframework.cloud.netflix.hystrix.EnableHystrix;
import org.springframework.cloud.netflix.hystrix.dashboard.EnableHystrixDashboard;
import org.springframework.cloud.netflix.zuul.EnableZuulProxy;
import org.springframework.context.ApplicationContext;
import org.springframework.core.env.Environment;

/**
 * Zuul 网关应用启动类
 * <p>该类是 AutumnNook 微服务架构中的 API 网关入口，负责统一的路由转发、
 * 服务发现、熔断降级和监控管理功能。</p>
 * <p><b>核心功能注解说明：</b></p>
 * <ul>
 *   <li>{@link EnableZuulProxy}：启用 Zuul 代理功能，提供动态路由和过滤器支持</li>
 *   <li>{@link EnableDiscoveryClient}：启用服务发现客户端，与注册中心交互</li>
 *   <li>{@link EnableHystrix}：启用 Hystrix 熔断器，提供服务的容错保护</li>
 *   <li>{@link EnableHystrixDashboard}：启用 Hystrix 仪表盘，提供熔断监控界面</li>
 *   <li>{@link SpringBootApplication}：Spring Boot 应用标准注解，包含组件扫描和自动配置</li>
 * </ul>
 * <p><b>应用架构定位：</b></p>
 * <ul>
 *   <li>作为微服务架构的统一入口网关</li>
 *   <li>负责请求路由和负载均衡</li>
 *   <li>提供统一的认证授权入口</li>
 *   <li>实现服务的熔断降级和限流保护</li>
 *   <li>收集和展示服务监控指标</li>
 * </ul>
 *
 * @author 蔡熙贝
 * @version 1.0
 * @see EnableZuulProxy
 * @see EnableDiscoveryClient
 * @see EnableHystrix
 * @since 2024
 */
@EnableHystrix                  // 启用 Hystrix 熔断器，提供服务的容错保护机制
@EnableZuulProxy                // 启用 Zuul 代理，提供动态路由、监控、弹性等功能
@SpringBootApplication          // Spring Boot 应用核心注解，包含配置、组件扫描等
@EnableDiscoveryClient          // 启用服务发现客户端，支持 Eureka、Consul 等注册中心
@EnableHystrixDashboard         // 启用 Hystrix 仪表盘，提供可视化的熔断器监控界面
public class ZuulApplication {

    /**
     * 日志记录器实例，用于输出应用启动和运行过程中的关键信息
     */
    private static final Logger logger = LoggerFactory.getLogger(ZuulApplication.class);

    /**
     * 应用主入口方法
     * <p><b>启动流程说明：</b></p>
     * <ol>
     *   <li>初始化 Spring 应用上下文，加载所有配置和 Bean</li>
     *   <li>启动内嵌的 Web 服务器（Undertow）</li>
     *   <li>注册到服务发现中心（Eureka）</li>
     *   <li>初始化 Zuul 路由配置和过滤器链</li>
     *   <li>启动 Hystrix 熔断器和监控仪表盘</li>
     *   <li>输出启动成功信息和关键配置参数</li>
     * </ol>
     * <p><b>关键配置输出：</b></p>
     * <ul>
     *   <li>服务端口：网关对外服务的端口号</li>
     *   <li>实例地址：当前实例在注册中心注册的地址</li>
     *   <li>服务发现配置：是否拉取和注册服务的开关状态</li>
     *   <li>注册中心地址：Eureka 服务器集群地址</li>
     *   <li>访问地址：应用启动后的可访问地址</li>
     *   <li>监控端点：Actuator 监控端点的访问地址</li>
     * </ul>
     *
     * @param args 命令行参数，可用于覆盖配置文件中的参数
     */
    public static void main(String[] args) {
        // 启动 Spring Boot 应用，返回应用上下文
        ApplicationContext context = SpringApplication.run(ZuulApplication.class, args);

        // 获取环境配置信息
        Environment environment = context.getEnvironment();

        // 从环境变量中读取关键配置信息
        String port = environment.getProperty("server.port");
        String fetchRegistry = environment.getProperty("eureka.client.fetch-registry");
        String registryWithEureka = environment.getProperty("eureka.client.register-with-eureka");
        String defaultZone = environment.getProperty("eureka.client.service-url.defaultZone");
        String hostname = environment.getProperty("eureka.instance.hostname");
        String preferIpAddress = environment.getProperty("eureka.instance.prefer-ip-address");

        // 输出应用启动成功信息和关键配置
        logger.info("========= AutumnNook Zuul started successfully =========");
        logger.info("🚀 服务端口：{}", port);
        logger.info("🏠 实例地址：{}", hostname);
        logger.info("📥 是否从注册中心拉取服务：{}", fetchRegistry);
        logger.info("📤 是否注册到注册中心：{}", registryWithEureka);
        logger.info("🔗 注册中心集群地址：{}", defaultZone);
        logger.info("🌐 是否优先使用服务器的IP地址：{}", preferIpAddress);
        logger.info("📊 访问地址：http://localhost:{}/", port);
        logger.info("👁️ 监控端点：http://localhost:{}/actuator", port);
        logger.info("========================================================");
    }

    static {
        // 注册 JVM 关闭钩子，确保应用优雅关闭
        Runtime.getRuntime().addShutdownHook(new Thread(() -> {
            logger.info("===================Autumnnook Zuul 正在关闭===================");
            logger.info("正在清理资源...");
            // 这里可以添加具体的资源清理逻辑，如：
            // - 关闭数据库连接池
            // - 释放 Redis 连接
            // - 从注册中心注销服务
            // - 停止后台线程等
            logger.info("资源清理完成，服务已关闭");
        }));
    }
}
```

### 配置路由规则

#### URL 地址路由

```yml
zuul:
  routes:
    autumnnook-system: # 路由 id 自定义
      path: /api/system/** # 配置请求 url 的映射路径
      url: http://autumnnook-system:18080 # 映射路径对应的微服务地址
    autumnnook-menu:
      path: /api/menu/**
      url: http://autumnnook-menu:18081
```

可以使用通配符，含义如下。

| 通配符 |             含义             |      举例      |                     解释                     |
| :----: | :--------------------------: | :------------: | :------------------------------------------: |
|   ?    |       匹配任意单个字符       | /api/system/?  |      /api/system/a，/api/system/b，...       |
|   *    | 匹配任意数量字符不包括子路径 | /api/system/*  |     /api/system/aa，/api/system/bbb，...     |
|   **   |  匹配任意数量字符包括子路径  | /api/system/** | /api/system/aa/bb，/api/system/bbb/cccc，... |

重启服务，访问结果如下：

![image-20251221010848379](assets/image-20251221010848379.png)

#### 服务名称路由

微服务一般由几十、上百个服务组成，对于 URL 地址路由的方式，如果对于每个服务实例手动指定一个唯一访问的地址，这样做显然是不合理的。

Zuul 支持与 Eureka 整合开发，根据 serviceId 自动从注册中心获取服务地址并转发请求，这样做的好处不仅可以通过单个端点来访问应用的所有服务，而且在添加或者移除服务时不用修改 Zuul 的路由配置。

##### 添加 Eureka Client 依赖

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
</dependency>
```

##### 配置注册中心和路由规则

```yml
# Zuul 网关应用配置文件
#
# 该配置文件定义了 Zuul API 网关的核心配置，包括服务器设置、Spring 应用配置、
# Zuul 网关特性和 Eureka 服务发现配置。
#
# 主要功能：
# - 配置网关服务器参数和性能优化
# - 定义 Zuul 路由和负载均衡行为
# - 配置服务注册与发现（Eureka）
# - 设置健康检查和监控端点
#
# 适用场景：
# - 微服务架构中的 API 网关
# - 服务路由和负载均衡
# - 请求过滤和权限控制
# - 服务注册发现和健康监控
server:
  # 服务器端口配置
  port: ${SERVER_PORT:30000}
  # Undertow 服务器性能优化配置
  # Undertow 是高性能的 NIO 服务器，适用于高并发场景
  undertow:
    # I/O 线程数，负责处理非阻塞 I/O 操作
    # 建议设置为 CPU 核心数的 1-2 倍
    io-threads: 16
    # 工作线程数，负责处理业务逻辑
    # 根据业务复杂度和并发量调整，通常设置为 I/O 线程数的 10-100 倍
    worker-threads: 1600
    # 是否使用直接内存缓冲区
    # true 表示使用堆外内存，减少 GC 压力，提高性能
    direct-buffers: true
  # Servlet 上下文路径配置
  # 定义应用访问的基础路径，所有请求都需要包含此路径
  servlet:
    context-path: /
spring:
  # 应用名称配置，用于服务注册和发现
  # 在 Eureka 中以此名称注册服务
  application:
    name: ${APPLICATION_NAME:autumnnook-zuul}
  # Spring MVC 配置
  mvc:
    # 当没有找到请求处理器时是否抛出异常
    # true: 抛出 NoHandlerFoundException，便于统一异常处理
    # false: 返回默认 404 页面
    throw-exception-if-no-handler-found: true
  # 静态资源映射配置
  resources:
    # 是否启用静态资源映射
    # true: 启用，可以访问静态资源文件
    # false: 禁用，适用于纯 API 网关场景
    add-mappings: false
# Zuul 网关核心配置
zuul:
  routes:
    autumnnook-system:
      path: /api/system/**
      service-id: ${AUTUMNLOOK_SYSTEM_SERVICE_ID:autumnnook-system}
    autumnnook-menu:
      path: /api/menu/**
      service-id: ${AUTUMNLOOK_MENU_SERVICE_ID:autumnnook-menu}
  # 信号量配置，用于控制并发请求数量
  semaphore:
    # 最大信号量数量，限制同时处理的请求数
    # 防止网关被过多请求压垮，起到熔断保护作用
    max-semaphores: 1100
  # 敏感请求头配置
  # 空数组表示不过滤任何请求头，所有头信息都会转发到下游服务
  sensitive-headers:
  # 是否剥离路由前缀
  # false: 保留完整路径转发到下游服务
  # true: 去除路由匹配的前缀部分
  strip-prefix: false
  # 是否添加 Host 头信息
  # true: 在转发请求时添加 Host 头，便于下游服务识别请求来源
  add-host-header: true
  # HTTP 客户端连接池配置
  host:
    # 最大总连接数，限制网关与所有下游服务的总连接数
    maxTotalConnections: 10000
    # 每个路由的最大连接数，限制到单个服务的最大连接数
    maxPerRouteConnections: 1100
    # Socket 超时时间（毫秒）
    # 设置与下游服务建立连接的超时时间
    socket-timeout-millis: 3600000
  # 是否忽略安全相关的响应头
  # false: 保留安全头信息（如 X-Content-Type-Options 等）
  ignoreSecurityHeaders: false
# Eureka 客户端配置
# 用于服务注册发现，网关需要注册到 Eureka 并发现其他服务
eureka:
  # 实例配置，定义当前服务实例的注册信息
  instance:
    # 实例主机名，用于服务发现时的地址解析
    hostname: ${HOSTNAME:${spring.application.name}}
    # 是否优先使用 IP 地址进行注册
    # false: 使用主机名注册
    # true: 使用 IP 地址注册，适用于容器化部署
    prefer-ip-address: ${PREFER_IP_ADDRESS:false}
    # 实例 ID 格式，在 Eureka 服务器中唯一标识此实例
    instance-id: ${spring.application.name}:${HOSTNAME:localhost}:${server.port}
    # 心跳续约间隔（秒）
    # 客户端向 Eureka 服务器发送心跳的频率
    lease-renewal-interval-in-seconds: ${LEASE_RENEWAL_INTERVAL_IN_SECONDS:10}
    # 租约过期时间（秒）
    # Eureka 服务器在多久没有收到心跳后认为实例下线
    lease-expiration-duration-in-seconds: 30
    # 状态页面 URL，用于展示实例状态信息
    status-page-url: http://${HOSTNAME:localhost}:${server.port}/actuator/info
    # 健康检查 URL，Eureka 服务器定期检查实例健康状态
    health-check-url: http://${HOSTNAME:localhost}:${server.port}/actuator/health
    # 主页 URL，实例的主页地址
    home-page-url: http://${HOSTNAME:localhost}:${server.port}
  # Eureka 客户端行为配置
  client:
    # 是否启用健康检查
    healthcheck:
      enabled: true
    # 是否从 Eureka 服务器获取注册表信息
    # true: 获取其他服务注册信息，用于服务发现
    fetch-registry: ${FETCH_REGISTRY:true}
    # 是否注册到 Eureka 服务器
    # true: 将本实例注册到 Eureka，供其他服务发现
    register-with-eureka: ${REGISTER_WITH_EUREKA:true}
    # Eureka 服务器地址配置
    service-url:
      # Eureka 服务器集群地址，支持多个地址用逗号分隔
      # 格式：协议://用户名:密码@主机名:端口/eureka/
      defaultZone: ${EUREKA_PEERS:http://soaadmin:jsepc01!@autumnnook-eureka:8761/eureka/}
```

#### 如何简化路由配置

Zuul 为了方便大家使用，提供了默认路由配置：路由 id 和 微服务名称一致，path 默认对应 `微服务名称/**` ，因此以下配置就不必再写了。

```yml
# 默认配置示例
zuul:
  routes:
    autumnnook-system:
      path: /autumnnook-system/**
    autumnnook-menu:
      path: /autumnnook-menu/**
```

也就是说即便我们将路由配置注释掉，同样也能成功访问服务，如下所示。

![image-20251221012543869](assets/image-20251221012543869.png)

到这里为止，我们结合服务名称路由和默认路由的启发，我们可以通过 Eureka 服务注册中心实现动态路由规则并自定义路由 id。需要通过继承 `SimpleRouteLocator` 并实现 `RefreshableRouteLocator` 接口。

- 自定义路由定位器

```java
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.cloud.client.ServiceInstance;
import org.springframework.cloud.client.discovery.DiscoveryClient;
import org.springframework.cloud.netflix.zuul.filters.RefreshableRouteLocator;
import org.springframework.cloud.netflix.zuul.filters.SimpleRouteLocator;
import org.springframework.cloud.netflix.zuul.filters.ZuulProperties;
import org.springframework.util.CollectionUtils;
import javax.annotation.Resource;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.atomic.AtomicInteger;
/**
 * 自定义动态路由定位器，用于从服务注册中心自动发现并创建Zuul路由规则
 * <p>该类继承 {@link SimpleRouteLocator} 并实现 {@link RefreshableRouteLocator} 接口，
 * 提供基于服务发现的路由动态管理能力。当服务在注册中心注册或注销时，路由规则会自动更新。</p>
 * <p><b>主要特性：</b></p>
 * <ul>
 *   <li>自动从服务注册中心发现所有可用服务</li>
 *   <li>为每个服务动态创建统一格式的路由规则</li>
 *   <li>支持路由配置的热刷新，无需重启网关</li>
 *   <li>与静态路由配置共存，动态路由优先</li>
 * </ul>
 * <p><b>使用场景：</b></p>
 * <ul>
 *   <li>微服务架构中服务动态上下线的场景</li>
 *   <li>需要自动为每个注册的服务创建统一路由规则的场景</li>
 *   <li>网关需要实时感知服务注册表变化的场景</li>
 * </ul>
 *
 * @author 蔡熙贝
 * @version 1.0
 * @since 2024
 */
public class SimpleRoutingLocater extends SimpleRouteLocator implements RefreshableRouteLocator {

    /**
     * 日志记录器实例，用于输出路由管理相关的日志信息
     */
    private static final Logger logger = LoggerFactory.getLogger(SimpleRoutingLocater.class);

    /**
     * 路由ID生成器，使用原子操作确保线程安全
     * <p>该生成器为每个动态创建的路由生成唯一标识符，格式为：discovery-{serviceName}-{sequence}</p>
     */
    private static final AtomicInteger ROUTE_ID_GENERATOR = new AtomicInteger(0);

    /**
     * 服务发现客户端，用于从注册中心获取服务信息
     * <p>支持的服务注册中心包括：Eureka、Consul、Nacos等Spring Cloud兼容的注册中心。</p>
     * <p>使用 {@link Resource} 注解实现依赖注入，确保在Spring容器初始化后自动注入。</p>
     */
    @Resource
    private DiscoveryClient discoveryClient;

    /**
     * 构造一个新的动态路由定位器实例
     *
     * @param servletPath 应用上下文路径，用于构建完整路由路径
     * @param properties  Zuul配置属性，包含路由相关的全局设置
     */
    public SimpleRoutingLocater(String servletPath, ZuulProperties properties) {
        super(servletPath, properties);
    }

    /**
     * 刷新路由配置，重新加载所有路由规则
     * <p>该方法会触发路由配置的重新加载过程，通常用于以下场景：</p>
     * <ul>
     *   <li>服务注册表发生变化时</li>
     *   <li>需要强制更新路由缓存时</li>
     *   <li>通过/actuator/refresh端点触发刷新时</li>
     * </ul>
     * <p><b>实现说明：</b>调用父类的{@code doRefresh()}方法重新加载所有路由。</p>
     */
    @Override
    public void refresh() {
        logger.debug("Refreshing zuul routes from discovery client");
        doRefresh();
    }

    /**
     * 定位所有可用的路由规则，包括静态配置和动态发现的路由
     * <p><b>路由加载流程：</b></p>
     * <ol>
     *   <li>首先加载配置文件中的静态路由（通过{@code super.locateRoutes()}）</li>
     *   <li>然后加载从服务发现获取的动态路由（通过{@code locateRoutesFromDiscovery()}）</li>
     *   <li>合并两类路由，动态路由会覆盖同路径的静态路由</li>
     *   <li>记录最终的路由数量和信息</li>
     * </ol>
     *
     * @return 包含所有路由规则的Map，key为路由路径模式，value为对应的路由配置对象
     * @see ZuulProperties.ZuulRoute
     */
    @Override
    protected Map<String, ZuulProperties.ZuulRoute> locateRoutes() {
        Map<String, ZuulProperties.ZuulRoute> routesMap = new LinkedHashMap<>();
        routesMap.putAll(super.locateRoutes());
        routesMap.putAll(locateRoutesFromDiscovery());
        if (logger.isInfoEnabled()) {
            logger.info("Loaded {} zuul routes: {}", routesMap.size(), routesMap.keySet());
        }
        return routesMap;
    }

    /**
     * 从服务发现客户端动态获取并生成路由配置
     * <p><b>处理流程：</b></p>
     * <ol>
     *   <li>获取所有已注册的服务名称列表</li>
     *   <li>检查服务发现是否正常，若无服务则记录警告</li>
     *   <li>遍历每个服务，获取其实例信息</li>
     *   <li>为每个服务创建对应的路由规则</li>
     *   <li>处理重复路由路径的情况</li>
     * </ol>
     * <p><b>异常处理：</b>当服务发现客户端异常时返回空映射，不影响静态路由的正常使用。</p>
     *
     * @return 动态生成的路由配置映射表，key为路由路径，value为路由配置对象
     */
    private Map<String, ZuulProperties.ZuulRoute> locateRoutesFromDiscovery() {
        Map<String, ZuulProperties.ZuulRoute> dynamicRoutes = new LinkedHashMap<>();
        List<String> services = discoveryClient.getServices();
        if (CollectionUtils.isEmpty(services)) {
            logger.warn("No services discovered from discovery client");
            return dynamicRoutes;
        }
        logger.debug("Discovered {} services: {}", services.size(), services);
        for (String serviceName : services) {
            List<ServiceInstance> instances = discoveryClient.getInstances(serviceName);
            if (CollectionUtils.isEmpty(instances)) {
                logger.debug("No instances found for service: {}", serviceName);
                continue;
            }
            ZuulProperties.ZuulRoute route = createRouteForService(serviceName, instances);
            String path = buildRoutePath(serviceName);
            if (!dynamicRoutes.containsKey(path)) {
                dynamicRoutes.put(path, route);
                logger.debug("Created route for service: {} -> {}", path, serviceName);
            } else {
                logger.warn("Duplicate route path detected: {}, skipping", path);
            }
        }
        return dynamicRoutes;
    }

    /**
     * 为指定服务创建路由配置对象
     * <p><b>路由配置详解：</b></p>
     * <ul>
     *   <li><b>id:</b> 路由唯一标识，用于路由管理和监控</li>
     *   <li><b>serviceId:</b> 服务标识，Zuul通过此值进行服务发现和负载均衡</li>
     *   <li><b>retryable:</b> 是否启用重试机制，生产环境建议根据业务需求设置</li>
     *   <li><b>stripPrefix:</b> 是否去除路径前缀，true表示转发时去掉服务名前缀</li>
     *   <li><b>path:</b> 路由匹配路径，用于匹配客户端请求</li>
     * </ul>
     * <p><b>设计考虑：</b>使用serviceId而非直接URL，充分利用Zuul的负载均衡能力。</p>
     *
     * @param serviceName 服务名称，用于设置serviceId和生成路由ID
     * @param instances   服务实例列表，用于记录实例数量信息（调试用）
     * @return 配置完整的Zuul路由对象
     */
    private ZuulProperties.ZuulRoute createRouteForService(String serviceName, List<ServiceInstance> instances) {
        ZuulProperties.ZuulRoute route = new ZuulProperties.ZuulRoute();
        String routeId = generateRouteId(serviceName);
        route.setId(routeId);
        route.setServiceId(serviceName);
        route.setRetryable(false);
        route.setStripPrefix(true);
        route.setPath(buildRoutePath(serviceName));
        if (logger.isDebugEnabled()) {
            logger.debug("Created route: id={}, serviceId={}, path={}, instances={}", routeId, serviceName, route.getPath(),
                instances.size());
        }
        return route;
    }

    /**
     * 生成唯一的路由标识符
     * <p><b>ID格式说明：</b></p>
     * <ul>
     *   <li><b>"discovery":</b> 标识此为动态发现的路由</li>
     *   <li><b>{serviceName}:</b> 关联的服务名称，便于识别</li>
     *   <li><b>{sequence}:</b> 自增序列号，使用{@link AtomicInteger}确保全局唯一性</li>
     * </ul>
     * <p><b>线程安全：</b>使用{@link AtomicInteger}确保并发环境下ID不会冲突。</p>
     *
     * @param serviceName 服务名称，作为ID的一部分
     * @return 格式为"discovery-{serviceName}-{sequence}"的唯一标识符
     */
    private String generateRouteId(String serviceName) {
        return "discovery-" + serviceName + "-" + ROUTE_ID_GENERATOR.incrementAndGet();
    }

    /**
     * 构建路由匹配路径
     * <p><b>路径规则说明：</b></p>
     * <ul>
     *   <li>使用服务名称作为路径前缀</li>
     *   <li>"/**"表示匹配该路径下的所有子路径</li>
     * </ul>
     * <p><b>示例：</b></p>
     * <ul>
     *   <li>服务"user-service"会生成路径"/user-service/**"</li>
     *   <li>请求"/user-service/api/users"会被路由到user-service服务</li>
     *   <li>请求"/user-service/api/orders"也会被路由到user-service服务</li>
     * </ul>
     * <p><b>可扩展性：</b>可根据需要修改路径生成规则，如添加版本前缀"/v1/{serviceName}/**"。</p>
     *
     * @param serviceName 服务名称
     * @return 格式为"/{serviceName}/**"的路由路径
     */
    private String buildRoutePath(String serviceName) {
        return "/" + serviceName + "/**";
    }
}
```

- 添加 Zuul 配置类，替换默认路由定位器，实现基于服务发现的动态路由管理

```java
import com.autumnnook.locator.SimpleRoutingLocater;
import lombok.RequiredArgsConstructor;
import org.springframework.boot.autoconfigure.web.ServerProperties;
import org.springframework.cloud.netflix.zuul.filters.SimpleRouteLocator;
import org.springframework.cloud.netflix.zuul.filters.ZuulProperties;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;
/**
 * Zuul网关配置类
 * <p>该类负责配置Zuul网关的核心组件，特别是自定义路由定位器的注册和初始化。
 * 通过替换默认的路由定位器，实现基于服务发现的动态路由管理。</p>
 * <p><b>主要功能：</b></p>
 * <ul>
 *   <li>配置自定义路由定位器Bean</li>
 *   <li>注入Zuul和服务器相关配置属性</li>
 *   <li>确保自定义路由定位器优先于默认实现</li>
 * </ul>
 * <p><b>配置说明：</b></p>
 * <ul>
 *   <li>使用{@link Configuration}标识为配置类</li>
 *   <li>使用{@link RequiredArgsConstructor}自动生成构造函数</li>
 *   <li>使用{@link Primary}确保自定义Bean优先被使用</li>
 * </ul>
 *
 * @author 蔡熙贝
 * @version 1.0
 * @see SimpleRoutingLocater
 * @see ZuulProperties
 * @see ServerProperties
 * @since 2024
 */
@Configuration
@RequiredArgsConstructor
public class ZuulConfig {

    /**
     * Zuul配置属性，包含路由、过滤器等全局配置
     * <p>该属性通过Spring Boot自动配置注入，包含以下重要配置项：</p>
     * <ul>
     *   <li><b>routes:</b> 静态路由配置</li>
     *   <li><b>prefix:</b> 路由前缀</li>
     *   <li><b>stripPrefix:</b> 是否剥离前缀</li>
     *   <li><b>retryable:</b> 是否可重试</li>
     *   <li><b>sensitiveHeaders:</b> 敏感头信息</li>
     * </ul>
     * <p>这些配置会影响所有路由的行为，包括动态生成的路由。</p>
     */
    private final ZuulProperties zuulProperties;

    /**
     * 服务器配置属性，包含服务器相关的配置信息
     * <p>该属性通过Spring Boot自动配置注入，主要包含：</p>
     * <ul>
     *   <li><b>servlet.context-path:</b> 应用上下文路径</li>
     *   <li><b>server.port:</b> 服务器端口</li>
     *   <li><b>server.address:</b> 服务器地址</li>
     * </ul>
     * <p>上下文路径用于构建完整的前端请求路径，确保路由匹配的正确性。</p>
     */
    private final ServerProperties serverProperties;

    /**
     * 创建并注册自定义路由定位器Bean
     * <p><b>Bean配置说明：</b></p>
     * <ul>
     *   <li>使用{@link Bean}注解将其声明为Spring Bean</li>
     *   <li>使用{@link Primary}注解确保该Bean优先于默认路由定位器</li>
     *   <li>Bean名称为"routeLocator"，与默认实现保持一致</li>
     * </ul>
     * <p><b>参数传递：</b></p>
     * <ul>
     *   <li><b>servletPath:</b> 从{@code serverProperties.getServlet().getContextPath()}获取，
     *       确保路由路径包含正确的上下文前缀</li>
     *   <li><b>zuulProperties:</b> 传递Zuul全局配置，使自定义定位器能够继承默认行为</li>
     * </ul>
     * <p><b>替换机制：</b></p>
     * <p>通过声明同名且标记为{@link Primary}的Bean，Spring容器会优先使用此自定义实现，
     * 从而替换Zuul默认的{@code org.springframework.cloud.netflix.zuul.filters.SimpleRouteLocator}。</p>
     *
     * @return 配置完成的自定义路由定位器实例
     * @see SimpleRoutingLocater#SimpleRoutingLocater(String, ZuulProperties)
     */
    @Bean
    public SimpleRouteLocator routeLocator() {
        return new SimpleRoutingLocater(serverProperties.getServlet().getContextPath(), zuulProperties);
    }
}
```

### 路由排除

我们可以通过路由排除设置不允许被访问的资源，允许被访问的资源可以通过路由规则进行设置。

#### URL 地址排除

```yml
zuul:
  ignored-patterns: /**/order/** # URL 地址排除，排除所有包含 /order/ 的请求不经过 Zuul 处理
  routes:
    autumnnook-system:
      path: /autumnnook-system/**
    autumnnook-menu:
      path: /autumnnook-menu/**
```

#### 服务名称排除

```yaml
zuul:
  ignored-services: autumnnook-test # 忽略的服务列表，避免对特定服务进行路由
  routes:
    autumnnook-system:
      path: /autumnnook-system/**
    autumnnook-menu:
      path: /autumnnook-menu/**
```

### 路由前缀

```yaml
zuul:
  prefix: /api # 全局路由前缀，所有请求路径前添加 /api
  # ignored-services: autumnnook-test # 忽略的服务列表，避免对特定服务进行路由
  # routes:
  #   autumnnook-system:
  #     path: /autumnnook-system/**
  #   autumnnook-menu:
  #     path: /autumnnook-menu/**
```

## 网关过滤器

<img src="assets/image-20251221014048934.png" alt="image-20251221014048934" style="zoom:50%;" />

Zuul 包含了对请求的路由和过滤两个核心功能，其中路由功能负责将外部请求转发到具体的微服务实例上，是实现外部访问统一入口的基础。而过滤器功能则负责对请求的处理过程进行干预，是是实现请求校验，服务聚合等功能的基础。然而实际上，路由功能在真正运行时，他的路由映射和请求转发都是由几个不同的过滤器完成的。

路由映射主要通过 `pre` 类型的过滤器完成，它将请求路径与配置的路由规则进行匹配，以找到需要转发的目标地址。而请求转发的部分则是由 `routing` 类型的过滤器来完成，对 `pre` 类型的过滤器获得的路由地址进行转发。

所以说，过滤器是 Zuul 实现 API 网关功能最核心的部件，每一个进入 Zuul 的 HTTP 请求都会经过一系列的过滤器处理链得到请求响应并返回给客户端。

### 关键名词

Zuul 网关作为微服务流量的统一入口，其核心价值建立在过滤器、路由、服务发现等基础概念之上。理解这些关键名词，是掌握网关架构设计的第一课。

- 类型：定义路由过程中应用过滤器的阶段，共 `pre` 、`routing`、`post`、`error` 4个类型；
- 执行顺序：在同类型中，定义过滤器执行的顺序，比如多个 `pre` 类型过滤器的执行顺序；
- 条件：执行过滤器所需要的条件，比如 `true` 为开启，`false` 为关闭； 
- 动作：如果符合条件，将要执行的具体操作；

### 过滤器类型

Zuul 的过滤器是其实现网关功能的基石。`PRE` 、`ROUTING` 、`POST` 、`ERROR` 四类过滤器构成完整的处理链条，每个环节承担着不同的流量治理职责。

- `pre`：请求被路由到源服务器之前执行的过滤器，可以称为前置过滤器。主要承担 **身份认证**、**路由**、**请求日志**。
- `routing`：处理将请求发送到源服务器的过滤器；
- `post`：响应从源服务器返回时执行的过滤器。主要承担 **对响应增加 HTTP 头**、**收集统计和度量指标**、**将响应以流的方式发送回客户端**；
- `error`：上述阶段中出现错误时执行的过滤器；

### 过滤器入门案例

#### 创建过滤器

Spring Cloud Netflix Zuul 中实现过滤器必须包含 4 个基本特征：

- 过滤器类型
- 执行顺序
- 执行条件
- 动作（具体操作）

这些步骤都是 ZuulFilter 接口中定义的 4 个抽象方法：

```java
import com.netflix.zuul.ZuulFilter;
import com.netflix.zuul.context.RequestContext;
import com.netflix.zuul.exception.ZuulException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;
import javax.servlet.http.HttpServletRequest;
/**
 * 自定义 Zuul 网关过滤器
 * 作用：实现请求级别的自定义处理逻辑，如日志记录、权限验证、参数校验等 生命周期：在请求经过 Zuul 网关时被调用，按照过滤器类型和顺序执行
 *
 * @author 蔡熙贝
 */
@Component  // 声明为 Spring 组件，自动注册到 Spring 容器
public class CustomZuulFilter extends ZuulFilter {

    // 日志记录器，用于输出过滤器执行信息
    private static final Logger logger = LoggerFactory.getLogger(CustomZuulFilter.class);

    /**
     * 过滤器类型定义
     * 返回值必须是以下四种类型之一： - "pre":    前置过滤器，在请求路由到目标服务之前执行 典型用途：身份验证、日志记录、限流等 - "route":  路由过滤器，负责将请求路由到具体的微服务 典型用途：HTTP请求转发、服务发现集成
     * - "post":   后置过滤器，在请求路由到目标服务之后执行 典型用途：响应头修改、统计信息收集、日志记录 - "error":  错误过滤器，当请求处理过程中发生错误时执行 典型用途：错误处理、异常响应格式化
     *
     * @return 过滤器类型字符串
     */
    @Override
    public String filterType() {
        return "pre";  // 当前过滤器为前置过滤器
    }

    /**
     * 过滤器执行顺序
     * 作用：当有多个同类型过滤器时，确定它们的执行顺序 规则：数值越小，优先级越高，执行越靠前 范围：可以是任意整数，通常使用 0, 1, 2, ... 等
     * 示例： - 认证过滤器：order = 0（最先执行，验证身份） - 日志过滤器：order = 1（其次执行，记录请求） - 参数校验过滤器：order = 2（最后执行，校验参数）
     *
     * @return 过滤器执行顺序的整数值
     */
    @Override
    public int filterOrder() {
        return 0;  // 最高优先级，最先执行
    }

    /**
     * 是否启用该过滤器
     * 作用：动态控制过滤器是否执行 返回值： - true:  执行该过滤器的 run() 方法 - false: 跳过该过滤器，不执行 run() 方法
     * 应用场景： 1. 根据请求路径决定是否执行（如只对 /api/** 路径生效） 2. 根据配置开关动态启用/禁用过滤器 3. 根据请求头或参数判断是否需要过滤
     *
     * @return 布尔值，表示是否执行该过滤器
     */
    @Override
    public boolean shouldFilter() {
        return true;  // 始终执行此过滤器
    }

    /**
     * 过滤器的核心业务逻辑
     * 作用：实现具体的过滤处理逻辑 执行时机：当 shouldFilter() 返回 true 时被调用
     * 关键对象： 1. RequestContext: Zuul 请求上下文，存储请求/响应信息 2. HttpServletRequest: 原始 HTTP 请求对象
     * 常用操作： 1. 获取请求信息：URL、方法、头信息、参数等 2. 修改请求：添加/删除请求头、修改请求参数 3. 中断请求：设置 context.setSendZuulResponse(false) 阻止转发 4.
     * 设置响应：直接返回响应，不转发到后端服务
     *
     * @return 通常返回 null，特殊情况下可返回任意对象
     * @throws ZuulException 处理过程中可能抛出的异常
     */
    @Override
    public Object run() throws ZuulException {
        // 获取当前请求的上下文对象
        // RequestContext 是线程安全的，存储了整个请求链路的共享数据
        RequestContext context = RequestContext.getCurrentContext();

        // 从上下文中获取原始的 HTTP 请求对象
        HttpServletRequest request = context.getRequest();

        // 记录请求日志：包含请求方法和完整URL
        // 实际生产环境中可添加更多信息：客户端IP、用户ID、请求时间等
        logger.info("CustomZuulFilter: {} request to {}", request.getMethod(),           // 请求方法：GET/POST/PUT/DELETE等
            request.getRequestURL().toString());  // 请求的完整URL

        // 可在此处添加更多业务逻辑：
        // 1. 身份验证：检查Token或Session
        // 2. 权限校验：验证用户是否有权访问该接口
        // 3. 参数校验：检查请求参数是否合法
        // 4. 限流检查：判断是否超过访问频率限制
        // 5. 请求修改：添加自定义请求头

        // 示例：添加自定义请求头
        // context.addZuulRequestHeader("X-Custom-Header", "CustomValue");

        // 示例：中断请求并返回自定义响应
        // if (!isValidRequest(request)) {
        //     context.setSendZuulResponse(false);  // 不转发到后端服务
        //     context.setResponseStatusCode(401);  // 设置响应状态码
        //     context.setResponseBody("Unauthorized");  // 设置响应体
        // }

        // 返回 null 表示过滤器正常执行完毕，继续后续处理
        // 如果返回非null对象，可能会影响过滤器链的执行（根据具体实现）
        return null;
    }

    /**
     * 辅助方法示例：验证请求是否合法 （实际使用时根据需求实现）
     *
     * @param request HTTP请求对象
     * @return 请求是否合法
     */
    private boolean isValidRequest(HttpServletRequest request) {
        // 示例验证逻辑：
        // 1. 检查必要的请求头是否存在
        // 2. 验证Token或签名
        // 3. 检查请求频率
        // 4. 验证参数格式
        return true;  // 默认返回true，实际应根据业务逻辑实现
    }

}
```

重启网关服务，测试上面我们的请求，然后观察控制台打印输出。

![image-20251222152348039](assets/image-20251222152348039.png)

### 统一鉴权

接下来我们在网关过滤器中通过 Token 判断用户是否登录，完成一个统一鉴权案例。

#### 创建过滤器

创建一个名为 AccessFilter 的过滤器，继承自 ZuulFilter 类。

```java
import com.netflix.zuul.ZuulFilter;
import com.netflix.zuul.context.RequestContext;
import com.netflix.zuul.exception.ZuulException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.io.PrintWriter;
/**
 * 自定义 Zuul 网关过滤器
 * 作用：实现请求级别的自定义处理逻辑，如日志记录、权限验证、参数校验等 生命周期：在请求经过 Zuul 网关时被调用，按照过滤器类型和顺序执行
 *
 * @author 蔡熙贝
 */
@Component  // 声明为 Spring 组件，自动注册到 Spring 容器
public class AccessFilter extends ZuulFilter {

    // 日志记录器，用于输出过滤器执行信息
    private static final Logger logger = LoggerFactory.getLogger(AccessFilter.class);

    /**
     * 过滤器类型定义
     * 返回值必须是以下四种类型之一： - "pre":    前置过滤器，在请求路由到目标服务之前执行 典型用途：身份验证、日志记录、限流等 - "route":  路由过滤器，负责将请求路由到具体的微服务 典型用途：HTTP请求转发、服务发现集成
     * - "post":   后置过滤器，在请求路由到目标服务之后执行 典型用途：响应头修改、统计信息收集、日志记录 - "error":  错误过滤器，当请求处理过程中发生错误时执行 典型用途：错误处理、异常响应格式化
     *
     * @return 过滤器类型字符串
     */
    @Override
    public String filterType() {
        return "pre";  // 当前过滤器为前置过滤器
    }

    /**
     * 过滤器执行顺序
     * 作用：当有多个同类型过滤器时，确定它们的执行顺序 规则：数值越小，优先级越高，执行越靠前 范围：可以是任意整数，通常使用 0, 1, 2, ... 等
     * 示例： - 认证过滤器：order = 0（最先执行，验证身份） - 日志过滤器：order = 1（其次执行，记录请求） - 参数校验过滤器：order = 2（最后执行，校验参数）
     *
     * @return 过滤器执行顺序的整数值
     */
    @Override
    public int filterOrder() {
        return 1;  // 最高优先级，最先执行
    }

    /**
     * 是否启用该过滤器
     * 作用：动态控制过滤器是否执行 返回值： - true:  执行该过滤器的 run() 方法 - false: 跳过该过滤器，不执行 run() 方法
     * 应用场景： 1. 根据请求路径决定是否执行（如只对 /api/** 路径生效） 2. 根据配置开关动态启用/禁用过滤器 3. 根据请求头或参数判断是否需要过滤
     *
     * @return 布尔值，表示是否执行该过滤器
     */
    @Override
    public boolean shouldFilter() {
        return true;  // 始终执行此过滤器
    }

    /**
     * 过滤器的核心业务逻辑
     * 作用：实现具体的过滤处理逻辑 执行时机：当 shouldFilter() 返回 true 时被调用
     * 关键对象： 1. RequestContext: Zuul 请求上下文，存储请求/响应信息 2. HttpServletRequest: 原始 HTTP 请求对象
     * 常用操作： 1. 获取请求信息：URL、方法、头信息、参数等 2. 修改请求：添加/删除请求头、修改请求参数 3. 中断请求：设置 context.setSendZuulResponse(false) 阻止转发 4.
     * 设置响应：直接返回响应，不转发到后端服务
     *
     * @return 通常返回 null，特殊情况下可返回任意对象
     * @throws ZuulException 处理过程中可能抛出的异常
     */
    @Override
    public Object run() throws ZuulException {
        // 获取当前请求的上下文对象
        // RequestContext 是线程安全的，存储了整个请求链路的共享数据
        RequestContext context = RequestContext.getCurrentContext();

        // 从上下文中获取原始的 HTTP 请求对象
        HttpServletRequest request = context.getRequest();

        // 记录请求日志：包含请求方法和完整URL
        // 实际生产环境中可添加更多信息：客户端IP、用户ID、请求时间等
        logger.info("AccessFilter: {} request to {}", request.getMethod(),           // 请求方法：GET/POST/PUT/DELETE等
            request.getRequestURL().toString());  // 请求的完整URL

        // 可在此处添加更多业务逻辑：
        // 1. 身份验证：检查Token或Session
        // 2. 权限校验：验证用户是否有权访问该接口
        // 3. 参数校验：检查请求参数是否合法
        // 4. 限流检查：判断是否超过访问频率限制
        // 5. 请求修改：添加自定义请求头
        String token = request.getParameter("token");
        if (token == null || token.isEmpty()) {
            logger.warn("AccessFilter: Missing token parameter");
            context.setSendZuulResponse(false);  // 不转发请求到后端服务
            context.setResponseStatusCode(HttpServletResponse.SC_UNAUTHORIZED);  // 设置响应状态码为 401 未授权
            context.setResponseBody("Unauthorized: Missing token");  // 设置响应体内容
            // return null;  // 结束过滤器执行
            context.getResponse().setContentType("application/json;charset=UTF-8");
            PrintWriter writer = null;
            try{
                writer = context.getResponse().getWriter();
                writer.write("{\"code\":401,\"message\":\"Unauthorized: Missing token\"}");
            }catch (IOException ex){
                ex.printStackTrace();
            }finally {
                if (null != writer){
                    writer.close();
                }
            }
        }else{
            logger.info("AccessFilter: Valid token received");
        }

        // 示例：添加自定义请求头
        // context.addZuulRequestHeader("X-Custom-Header", "CustomValue");

        // 示例：中断请求并返回自定义响应
        // if (!isValidRequest(request)) {
        //     context.setSendZuulResponse(false);  // 不转发到后端服务
        //     context.setResponseStatusCode(401);  // 设置响应状态码
        //     context.setResponseBody("Unauthorized");  // 设置响应体
        // }

        // 返回 null 表示过滤器正常执行完毕，继续后续处理
        // 如果返回非null对象，可能会影响过滤器链的执行（根据具体实现）
        return null;
    }

    /**
     * 辅助方法示例：验证请求是否合法 （实际使用时根据需求实现）
     *
     * @param request HTTP请求对象
     * @return 请求是否合法
     */
    private boolean isValidRequest(HttpServletRequest request) {
        // 示例验证逻辑：
        // 1. 检查必要的请求头是否存在
        // 2. 验证Token或签名
        // 3. 检查请求频率
        // 4. 验证参数格式
        return true;  // 默认返回true，实际应根据业务逻辑实现
    }
}
```

重启网关服务，测试上面我们的请求，然后观察控制台打印及页面输出。

![image-20251222153615574](assets/image-20251222153615574.png)

![image-20251222153753154](assets/image-20251222153753154.png)

## Zuul 请求生命周期

<img src="assets/image-20251222153856735.png" alt="image-20251222153856735" style="zoom:50%;" />

生命周期步骤分析：

1. HTTP 发送请求至 Zuul 网关；
2. Zuul 网关首先经过 pre filter ，验证通过后进入 routing filter；
3. 接着将请求转发给远程服务，远程服务执行完返回结果，如果出错，则执行 error filter；
4. 未出错则继续往下执行 post filter；
5. 最后返回响应给 HTTP 客户端；

## 网关过滤器异常统一处理

### 创建过滤器

创建一个名为 ErrorFilter 的过滤器，继承自 ZuulFilter 类。

```java
import com.netflix.zuul.ZuulFilter;
import com.netflix.zuul.context.RequestContext;
import com.netflix.zuul.exception.ZuulException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.io.PrintWriter;
/**
 * 自定义 Zuul 网关过滤器 作用：实现请求级别的自定义处理逻辑，如日志记录、权限验证、参数校验等 生命周期：在请求经过 Zuul 网关时被调用，按照过滤器类型和顺序执行
 *
 * @author 蔡熙贝
 */
@Component
public class ErrorFilter extends ZuulFilter {

    private static final Logger logger = LoggerFactory.getLogger(ErrorFilter.class);

    /**
     * 过滤器类型定义 返回值必须是以下四种类型之一： - "pre":    前置过滤器，在请求路由到目标服务之前执行 典型用途：身份验证、日志记录、限流等 - "route":  路由过滤器，负责将请求路由到具体的微服务
     * 典型用途：HTTP请求转发、服务发现集成 - "post":   后置过滤器，在请求路由到目标服务之后执行 典型用途：响应头修改、统计信息收集、日志记录 - "error":  错误过滤器，当请求处理过程中发生错误时执行
     * 典型用途：错误处理、异常响应格式化
     *
     * @return 过滤器类型字符串
     */
    @Override
    public String filterType() {
        return "error";
    }

    /**
     * 过滤器执行顺序 作用：当有多个同类型过滤器时，确定它们的执行顺序 规则：数值越小，优先级越高，执行越靠前 范围：可以是任意整数，通常使用 0, 1, 2, ... 等 示例： - 认证过滤器：order = 0（最先执行，验证身份） -
     * 日志过滤器：order = 1（其次执行，记录请求） - 参数校验过滤器：order = 2（最后执行，校验参数）
     *
     * @return 过滤器执行顺序的整数值
     */
    @Override
    public int filterOrder() {
        return 0;
    }

    /**
     * 是否启用该过滤器 作用：动态控制过滤器是否执行 返回值： - true:  执行该过滤器的 run() 方法 - false: 跳过该过滤器，不执行 run() 方法 应用场景： 1. 根据请求路径决定是否执行（如只对 /api/**
     * 路径生效） 2. 根据配置开关动态启用/禁用过滤器 3. 根据请求头或参数判断是否需要过滤
     *
     * @return 布尔值，表示是否执行该过滤器
     */
    @Override
    public boolean shouldFilter() {
        return true;
    }

    /**
     * 过滤器的核心业务逻辑 作用：实现具体的过滤处理逻辑 执行时机：当 shouldFilter() 返回 true 时被调用 关键对象： 1. RequestContext: Zuul 请求上下文，存储请求/响应信息 2.
     * HttpServletRequest: 原始 HTTP 请求对象 常用操作： 1. 获取请求信息：URL、方法、头信息、参数等 2. 修改请求：添加/删除请求头、修改请求参数 3. 中断请求：设置
     * context.setSendZuulResponse(false) 阻止转发 4. 设置响应：直接返回响应，不转发到后端服务
     *
     * @return 通常返回 null，特殊情况下可返回任意对象
     * @throws ZuulException 处理过程中可能抛出的异常
     */
    @Override
    public Object run() throws ZuulException {
        RequestContext context = RequestContext.getCurrentContext();
        HttpServletRequest request = context.getRequest();
        logger.info("ErrorFilter: {} request to {}", request.getMethod(), request.getRequestURL().toString());
        context.setSendZuulResponse(false);
        context.setResponseStatusCode(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
        context.setResponseBody("Unauthorized: Missing token");
        context.getResponse().setContentType("application/json;charset=UTF-8");
        PrintWriter writer = null;
        try {
            writer = context.getResponse().getWriter();
            writer.write("{\"code\":500,\"message\":\"服务器异常\"}");
        } catch (IOException ex) {
            ex.printStackTrace();
        } finally {
            if (null != writer) {
                writer.close();
            }
        }
        return null;
    }

}
```

### 模拟异常

在 pre 过滤器中添加模拟异常代码。

```java
int r = 1 / 0;
```

### 配置异常过滤器

禁用 Zuul 默认的异常处理 filter：`SendErrorFilter`

```yml
zuul:
  SendErrorFilter:
    # 是否启用发送错误过滤器
    # true: 启用，处理请求过程中出现的错误并返回适当响应
    # false: 禁用，不处理错误
    error:
      disable: true
```

重启服务器，发起请求之后，浏览器输出报错信息。

![image-20251222161016645](assets/image-20251222161016645.png)

## Zuul 和 Hystrix 无缝结合

在 Spring Cloud 中，Zuul 启动器中包含了 Hystrix 相关依赖。在 Zuul 网关中，默认提供了 Hystrix Dashboard 服务监控数据（hystrix.stream），但是没有提供监控面板的界面展示。Zuul 和 Hystrix 是无缝结合的，我们可以非常方便的实现网关容错处理。

### 网关监控

#### 添加依赖

Zuul 的依赖中包含了 Hystrix 的相关 jar 包，所以我们不需要在项目中额外添加 Hystrix 的依赖，但是如果需要开启数据监控则需要添加 dashboard 相关依赖。

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-hystrix-dashboard</artifactId>
</dependency>
```

#### 配置文件

在配置文件中开启 `hystrix.stream` 端点。

```yaml
management:
  endpoints:
    web:
      exposure:
        include: hystrix.stream
```

#### 启动类

在需要开启数据监控的项目启动类添加 `@EnableHystrixDashboard` 、`@EnableHystrix `注解。

```java
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.client.discovery.EnableDiscoveryClient;
import org.springframework.cloud.netflix.hystrix.EnableHystrix;
import org.springframework.cloud.netflix.hystrix.dashboard.EnableHystrixDashboard;
import org.springframework.cloud.netflix.zuul.EnableZuulProxy;
import org.springframework.context.ApplicationContext;
import org.springframework.core.env.Environment;
/**
 * Zuul 网关应用启动类
 * <p>该类是 AutumnNook 微服务架构中的 API 网关入口，负责统一的路由转发、
 * 服务发现、熔断降级和监控管理功能。</p>
 * <p><b>核心功能注解说明：</b></p>
 * <ul>
 *   <li>{@link EnableZuulProxy}：启用 Zuul 代理功能，提供动态路由和过滤器支持</li>
 *   <li>{@link EnableDiscoveryClient}：启用服务发现客户端，与注册中心交互</li>
 *   <li>{@link EnableHystrix}：启用 Hystrix 熔断器，提供服务的容错保护</li>
 *   <li>{@link EnableHystrixDashboard}：启用 Hystrix 仪表盘，提供熔断监控界面</li>
 *   <li>{@link SpringBootApplication}：Spring Boot 应用标准注解，包含组件扫描和自动配置</li>
 * </ul>
 * <p><b>应用架构定位：</b></p>
 * <ul>
 *   <li>作为微服务架构的统一入口网关</li>
 *   <li>负责请求路由和负载均衡</li>
 *   <li>提供统一的认证授权入口</li>
 *   <li>实现服务的熔断降级和限流保护</li>
 *   <li>收集和展示服务监控指标</li>
 * </ul>
 *
 * @author 蔡熙贝
 * @version 1.0
 * @see EnableZuulProxy
 * @see EnableDiscoveryClient
 * @see EnableHystrix
 * @since 2024
 */
@EnableHystrix                  // 启用 Hystrix 熔断器，提供服务的容错保护机制
@EnableZuulProxy                // 启用 Zuul 代理，提供动态路由、监控、弹性等功能
@SpringBootApplication          // Spring Boot 应用核心注解，包含配置、组件扫描等
@EnableDiscoveryClient          // 启用服务发现客户端，支持 Eureka、Consul 等注册中心
@EnableHystrixDashboard         // 启用 Hystrix 仪表盘，提供可视化的熔断器监控界面
public class ZuulApplication {

    /**
     * 日志记录器实例，用于输出应用启动和运行过程中的关键信息
     */
    private static final Logger logger = LoggerFactory.getLogger(ZuulApplication.class);

    /**
     * 应用主入口方法
     * <p><b>启动流程说明：</b></p>
     * <ol>
     *   <li>初始化 Spring 应用上下文，加载所有配置和 Bean</li>
     *   <li>启动内嵌的 Web 服务器（Undertow）</li>
     *   <li>注册到服务发现中心（Eureka）</li>
     *   <li>初始化 Zuul 路由配置和过滤器链</li>
     *   <li>启动 Hystrix 熔断器和监控仪表盘</li>
     *   <li>输出启动成功信息和关键配置参数</li>
     * </ol>
     * <p><b>关键配置输出：</b></p>
     * <ul>
     *   <li>服务端口：网关对外服务的端口号</li>
     *   <li>实例地址：当前实例在注册中心注册的地址</li>
     *   <li>服务发现配置：是否拉取和注册服务的开关状态</li>
     *   <li>注册中心地址：Eureka 服务器集群地址</li>
     *   <li>访问地址：应用启动后的可访问地址</li>
     *   <li>监控端点：Actuator 监控端点的访问地址</li>
     * </ul>
     *
     * @param args 命令行参数，可用于覆盖配置文件中的参数
     */
    public static void main(String[] args) {
        // 启动 Spring Boot 应用，返回应用上下文
        ApplicationContext context = SpringApplication.run(ZuulApplication.class, args);

        // 获取环境配置信息
        Environment environment = context.getEnvironment();

        // 从环境变量中读取关键配置信息
        String port = environment.getProperty("server.port");
        String fetchRegistry = environment.getProperty("eureka.client.fetch-registry");
        String registryWithEureka = environment.getProperty("eureka.client.register-with-eureka");
        String defaultZone = environment.getProperty("eureka.client.service-url.defaultZone");
        String hostname = environment.getProperty("eureka.instance.hostname");
        String preferIpAddress = environment.getProperty("eureka.instance.prefer-ip-address");

        // 输出应用启动成功信息和关键配置
        logger.info("========= AutumnNook Zuul started successfully =========");
        logger.info("🚀 服务端口：{}", port);
        logger.info("🏠 实例地址：{}", hostname);
        logger.info("📥 是否从注册中心拉取服务：{}", fetchRegistry);
        logger.info("📤 是否注册到注册中心：{}", registryWithEureka);
        logger.info("🔗 注册中心集群地址：{}", defaultZone);
        logger.info("🌐 是否优先使用服务器的IP地址：{}", preferIpAddress);
        logger.info("📊 访问地址：http://localhost:{}/", port);
        logger.info("👁️ 监控端点：http://localhost:{}/actuator", port);
        logger.info("========================================================");
    }

    static {
        // 注册 JVM 关闭钩子，确保应用优雅关闭
        Runtime.getRuntime().addShutdownHook(new Thread(() -> {
            logger.info("===================Autumnnook Zuul 正在关闭===================");
            logger.info("正在清理资源...");
            // 这里可以添加具体的资源清理逻辑，如：
            // - 关闭数据库连接池
            // - 释放 Redis 连接
            // - 从注册中心注销服务
            // - 停止后台线程等
            logger.info("资源清理完成，服务已关闭");
        }));
    }
}

```

#### 访问并查看数据

重启服务，访问并查看数据，访问 http://127.0.0.1:30000/hystrix

![image-20251222170631890](assets/image-20251222170631890.png)



![image-20251222170740832](assets/image-20251222170740832.png)

监控端点地址：http://127.0.0.1:30000/actuator/hystrix.stream 

![image-20251222170303388](assets/image-20251222170303388.png)



### 网关熔断

在 Edgeware 版本之前，Zuul 提供了接口 `ZuulFallbackProvider` 用于实现 fallback 处理。从 Edgeware 版本开始，Zuul 提供了接口 `FallbackProvider` 接口来提供 fallback 处理。

Zuul 的 fallback 容错处理逻辑，只针对 timeout 异常处理，当请求被 Zuul 路由后，只要服务有返回（包括异常），都不会触发 Zuul 的 fallback 容错逻辑。

<span style="color:#d44e7d;font-size:12px;">因为对于 Zuul 网关而言，做请求路由分发的时候，结果由远程服务运算。远程服务反馈了异常信息，Zuul 网关不会处理异常，因为无法确定这个错误是否是应用程序真实要反馈给客户端的。</span>

#### 特定服务的降级提供者

```java
import org.springframework.cloud.netflix.zuul.filters.route.FallbackProvider;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.client.ClientHttpResponse;
import org.springframework.stereotype.Component;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
/**
 * 系统服务降级提供者
 * 作用：当 Zuul 网关路由的后端服务不可用（超时、宕机、熔断等）时， 提供自定义的降级响应，避免客户端收到原始错误信息
 * 核心概念： 
 * 1. 服务降级：在服务不可用时返回预设的友好响应，而不是错误堆栈 
 * 2. 熔断触发：当 Hystrix 熔断器打开或服务调用失败时自动触发 
 * 3. 优雅降级：保证系统在部分服务故障时仍能提供基本功能
 * 应用场景： - 后端服务宕机或维护 - 服务调用超时 - 服务熔断器打开 - 网络异常导致服务不可达
 *
 * @author 蔡熙贝
 */
@Component
public class SystemFallbackProvider implements FallbackProvider {

    /**
     * 指定该降级提供者适用的服务路由
     * 返回值规则： 1. 返回具体服务名：只对该服务生效（如 "user-service"） 2. 返回 "*" 或 null：对所有服务生效（全局降级） 3. 返回特定路由ID：对指定路由生效
     * 注意：服务名需要与 zuul.routes 配置中的 serviceId 一致， 或者与 Eureka 注册的服务名一致
     *
     * @return 服务路由标识符
     */
    @Override
    public String getRoute() {
        // 返回 "autumnnook-system" 表示此降级提供者
        // 仅对名为 "autumnnook-system" 的后端服务生效
        return "autumnnook-system";
    }

    /**
     * 创建降级响应
     * 触发时机： 1. 后端服务调用超时（默认1秒，可配置） 2. 服务抛出异常（5xx、4xx 错误） 3. Hystrix 熔断器打开 4. 服务实例不存在或下线
     *
     * @param route 触发降级的服务路由（与 getRoute() 返回值一致）
     * @param cause 导致降级的异常对象，可用于判断降级原因 常见异常类型： - HystrixTimeoutException: 超时 - ZuulException: Zuul内部异常 - RuntimeException:
     *              运行时异常 - IOException: 网络IO异常
     * @return 自定义的 HTTP 响应对象
     */
    @Override
    public ClientHttpResponse fallbackResponse(String route, Throwable cause) {

        // 返回一个匿名内部类实现的 ClientHttpResponse 接口
        return new ClientHttpResponse() {

            /**
             * 响应状态码
             *
             * 设计建议：
             * 1. 服务暂时不可用：503 Service Unavailable
             * 2. 请求超时：504 Gateway Timeout
             * 3. 熔断器打开：429 Too Many Requests
             * 4. 通用错误：500 Internal Server Error
             *
             * 可以根据 cause 类型返回不同的状态码
             *
             * @return HTTP 状态码枚举
             * @throws IOException
             */
            @Override
            public HttpStatus getStatusCode() throws IOException {
                // 返回 500 内部服务器错误
                // 实际可根据业务需求调整：
                // if (cause instanceof HystrixTimeoutException) {
                //     return HttpStatus.GATEWAY_TIMEOUT; // 504
                // } else if (cause instanceof ConnectException) {
                //     return HttpStatus.SERVICE_UNAVAILABLE; // 503
                // }
                return HttpStatus.INTERNAL_SERVER_ERROR;
            }

            /**
             * 原始状态码（数值形式）
             *
             * 注意：此方法返回 int 类型状态码，
             *       应与 getStatusCode() 方法保持一致
             *
             * @return HTTP 状态码的整数值
             * @throws IOException
             */
            @Override
            public int getRawStatusCode() throws IOException {
                // 返回状态码的数值形式，500
                return getStatusCode().value();
            }

            /**
             * 状态文本描述
             *
             * 示例：
             * - 200: "OK"
             * - 404: "Not Found"
             * - 500: "Internal Server Error"
             *
             * @return 状态码对应的文本描述
             * @throws IOException
             */
            @Override
            public String getStatusText() throws IOException {
                // 返回状态码对应的标准描述文本
                // HttpStatus.INTERNAL_SERVER_ERROR.getReasonPhrase() = "Internal Server Error"
                return this.getStatusCode().getReasonPhrase();
            }

            /**
             * 关闭响应资源
             *
             * 作用：释放响应相关的资源（如输入流、网络连接等）
             * 注意：如果响应体是 ByteArrayInputStream，通常不需要特殊处理
             */
            @Override
            public void close() {
                // ByteArrayInputStream 不需要显式关闭
                // 如果是其他需要关闭的资源（如文件流、网络流），应在此处释放
            }

            /**
             * 响应体内容
             *
             * 设计原则：
             * 1. 返回友好的错误信息，避免技术细节暴露
             * 2. 保持统一的响应格式（JSON/XML）
             * 3. 包含必要的错误代码和用户提示
             * 4. 可添加请求ID便于追踪
             * @return 响应体的输入流
             * @throws IOException
             */
            @Override
            public InputStream getBody() throws IOException {
                // 创建 JSON 格式的降级响应体
                String fallbackJson = "{\"message\":\"System service is unavailable. Please try again later.\"}";
                // 可根据不同的异常类型返回不同的降级信息
                // if (cause instanceof HystrixTimeoutException) {
                //     fallbackJson = "{\"code\":\"TIMEOUT\",\"message\":\"请求超时，请稍后重试\"}";
                // } else if (cause instanceof ConnectException) {
                //     fallbackJson = "{\"code\":\"SERVICE_DOWN\",\"message\":\"服务暂时不可用\"}";
                // }
                // 将 JSON 字符串转换为字节输入流
                return new ByteArrayInputStream(fallbackJson.getBytes());
                // 注意：这里使用默认字符集（UTF-8），
                // 如果需要指定字符集，可以使用：fallbackJson.getBytes(StandardCharsets.UTF_8)
            }

            /**
             * 响应头信息
             *
             * 必须设置 Content-Type，否则客户端可能无法正确解析响应体
             * 建议设置：
             * 1. Content-Type: 响应体格式（application/json）
             * 2. Charset: 字符编码（UTF-8）
             * 3. Cache-Control: 缓存控制（no-cache）
             * 4. 自定义头：如 X-Fallback-Reason
             *
             * @return HTTP 响应头集合
             */
            @Override
            public HttpHeaders getHeaders() {
                // 创建响应头对象
                HttpHeaders headers = new HttpHeaders();
                // 设置内容类型为 JSON，字符编码为 UTF-8
                // 这是最重要的响应头，必须设置
                headers.add("Content-Type", "application/json; charset=UTF-8");
                // 可添加其他响应头：
                // headers.add("Cache-Control", "no-cache, no-store, max-age=0, must-revalidate");
                // headers.add("Pragma", "no-cache");
                // headers.add("Expires", "0");
                // headers.add("X-Fallback-Reason", cause != null ? cause.getClass().getSimpleName() : "unknown");
                // headers.add("X-Service-Name", route);
                return headers;
            }
        };
    }

    /**
     * 可选：获取降级原因（Spring Cloud 更高版本支持）
     * 用于在日志或监控中记录降级的具体原因
     *
     * @param route 服务路由
     * @param cause 异常原因
     * @return 降级原因描述
     */
    public String getFallbackReason(String route, Throwable cause) {
        if (cause == null) {
            return "Unknown reason for route: " + route;
        }
        // 根据异常类型返回不同的原因描述
        String causeType = cause.getClass().getSimpleName();
        String causeMessage = cause.getMessage();
        return String.format("Fallback triggered for %s. Cause: %s - %s", route, causeType, causeMessage);
    }
}
```

重启网关服务，我们将要访问的那个服务停掉，模拟调用服务超时。

![image-20251222174310741](assets/image-20251222174310741.png)

#### 通用的全局降级提供者

```java
import org.springframework.cloud.netflix.zuul.filters.route.FallbackProvider;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.client.ClientHttpResponse;
import org.springframework.stereotype.Component;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
/**
 * 系统服务降级提供者
 * 作用：当 Zuul 网关路由的后端服务不可用（超时、宕机、熔断等）时， 提供自定义的降级响应，避免客户端收到原始错误信息
 * 核心概念： 1. 服务降级：在服务不可用时返回预设的友好响应，而不是错误堆栈 2. 熔断触发：当 Hystrix 熔断器打开或服务调用失败时自动触发 3. 优雅降级：保证系统在部分服务故障时仍能提供基本功能
 * 应用场景： - 后端服务宕机或维护 - 服务调用超时 - 服务熔断器打开 - 网络异常导致服务不可达
 *
 * @author 蔡熙贝
 */
@Component
public class SystemFallbackProvider implements FallbackProvider {

    /**
     * 指定该降级提供者适用的服务路由
     * 返回值规则： 1. 返回具体服务名：只对该服务生效（如 "user-service"） 2. 返回 "*" 或 null：对所有服务生效（全局降级） 3. 返回特定路由ID：对指定路由生效
     * 注意：服务名需要与 zuul.routes 配置中的 serviceId 一致， 或者与 Eureka 注册的服务名一致
     *
     * @return 服务路由标识符
     */
    @Override
    public String getRoute() {
        return "*";//通用全局服务
    }

    /**
     * 创建降级响应
     * 触发时机： 1. 后端服务调用超时（默认1秒，可配置） 2. 服务抛出异常（5xx、4xx 错误） 3. Hystrix 熔断器打开 4. 服务实例不存在或下线
     *
     * @param route 触发降级的服务路由（与 getRoute() 返回值一致）
     * @param cause 导致降级的异常对象，可用于判断降级原因 常见异常类型： - HystrixTimeoutException: 超时 - ZuulException: Zuul内部异常 - RuntimeException:
     *              运行时异常 - IOException: 网络IO异常
     * @return 自定义的 HTTP 响应对象
     */
    @Override
    public ClientHttpResponse fallbackResponse(String route, Throwable cause) {

        // 返回一个匿名内部类实现的 ClientHttpResponse 接口
        return new ClientHttpResponse() {

            /**
             * 响应状态码
             *
             * 设计建议：
             * 1. 服务暂时不可用：503 Service Unavailable
             * 2. 请求超时：504 Gateway Timeout
             * 3. 熔断器打开：429 Too Many Requests
             * 4. 通用错误：500 Internal Server Error
             *
             * 可以根据 cause 类型返回不同的状态码
             *
             * @return HTTP 状态码枚举
             * @throws IOException
             */
            @Override
            public HttpStatus getStatusCode() throws IOException {
                // 返回 500 内部服务器错误
                // 实际可根据业务需求调整：
                // if (cause instanceof HystrixTimeoutException) {
                //     return HttpStatus.GATEWAY_TIMEOUT; // 504
                // } else if (cause instanceof ConnectException) {
                //     return HttpStatus.SERVICE_UNAVAILABLE; // 503
                // }
                return HttpStatus.INTERNAL_SERVER_ERROR;
            }

            /**
             * 原始状态码（数值形式）
             *
             * 注意：此方法返回 int 类型状态码，
             *       应与 getStatusCode() 方法保持一致
             *
             * @return HTTP 状态码的整数值
             * @throws IOException
             */
            @Override
            public int getRawStatusCode() throws IOException {
                // 返回状态码的数值形式，500
                return getStatusCode().value();
            }

            /**
             * 状态文本描述
             *
             * 示例：
             * - 200: "OK"
             * - 404: "Not Found"
             * - 500: "Internal Server Error"
             *
             * @return 状态码对应的文本描述
             * @throws IOException
             */
            @Override
            public String getStatusText() throws IOException {
                // 返回状态码对应的标准描述文本
                // HttpStatus.INTERNAL_SERVER_ERROR.getReasonPhrase() = "Internal Server Error"
                return this.getStatusCode().getReasonPhrase();
            }

            /**
             * 关闭响应资源
             *
             * 作用：释放响应相关的资源（如输入流、网络连接等）
             * 注意：如果响应体是 ByteArrayInputStream，通常不需要特殊处理
             */
            @Override
            public void close() {
                // ByteArrayInputStream 不需要显式关闭
                // 如果是其他需要关闭的资源（如文件流、网络流），应在此处释放
            }

            /**
             * 响应体内容
             *
             * 设计原则：
             * 1. 返回友好的错误信息，避免技术细节暴露
             * 2. 保持统一的响应格式（JSON/XML）
             * 3. 包含必要的错误代码和用户提示
             * 4. 可添加请求ID便于追踪
             * @return 响应体的输入流
             * @throws IOException
             */
            @Override
            public InputStream getBody() throws IOException {
                // 创建 JSON 格式的降级响应体
                String fallbackJson = "{\"message\":\"service is unavailable. please try again later.\"}";
                // 可根据不同的异常类型返回不同的降级信息
                // if (cause instanceof HystrixTimeoutException) {
                //     fallbackJson = "{\"code\":\"TIMEOUT\",\"message\":\"请求超时，请稍后重试\"}";
                // } else if (cause instanceof ConnectException) {
                //     fallbackJson = "{\"code\":\"SERVICE_DOWN\",\"message\":\"服务暂时不可用\"}";
                // }
                // 将 JSON 字符串转换为字节输入流
                return new ByteArrayInputStream(fallbackJson.getBytes());
                // 注意：这里使用默认字符集（UTF-8），
                // 如果需要指定字符集，可以使用：fallbackJson.getBytes(StandardCharsets.UTF_8)
            }

            /**
             * 响应头信息
             *
             * 必须设置 Content-Type，否则客户端可能无法正确解析响应体
             * 建议设置：
             * 1. Content-Type: 响应体格式（application/json）
             * 2. Charset: 字符编码（UTF-8）
             * 3. Cache-Control: 缓存控制（no-cache）
             * 4. 自定义头：如 X-Fallback-Reason
             *
             * @return HTTP 响应头集合
             */
            @Override
            public HttpHeaders getHeaders() {
                // 创建响应头对象
                HttpHeaders headers = new HttpHeaders();
                // 设置内容类型为 JSON，字符编码为 UTF-8
                // 这是最重要的响应头，必须设置
                headers.add("Content-Type", "application/json; charset=UTF-8");
                // 可添加其他响应头：
                // headers.add("Cache-Control", "no-cache, no-store, max-age=0, must-revalidate");
                // headers.add("Pragma", "no-cache");
                // headers.add("Expires", "0");
                // headers.add("X-Fallback-Reason", cause != null ? cause.getClass().getSimpleName() : "unknown");
                // headers.add("X-Service-Name", route);
                return headers;
            }
        };
    }

    /**
     * 可选：获取降级原因（Spring Cloud 更高版本支持）
     * 用于在日志或监控中记录降级的具体原因
     *
     * @param route 服务路由
     * @param cause 异常原因
     * @return 降级原因描述
     */
    public String getFallbackReason(String route, Throwable cause) {
        if (cause == null) {
            return "Unknown reason for route: " + route;
        }
        // 根据异常类型返回不同的原因描述
        String causeType = cause.getClass().getSimpleName();
        String causeMessage = cause.getMessage();
        return String.format("Fallback triggered for %s. Cause: %s - %s", route, causeType, causeMessage);
    }
}
```

<span style="color:#d44e7d;font-size:12px;">注：针对 OpenFeign 服务间调用，网关熔断降级逻辑是不生效的！</span>

###  网关限流

顾名思义，限流就是限制流量，就像你带宽包只有 1 个 G 的流量，用完了就没了。通过限流，我们可以很好的控制系统的 QPS，从而达到保护系统的目的。Zuul 网关组件也提供了限流保护。当请求并发达到了阈值，自动触发限流保护，返回错误结果。只要提供 error 错误处理机制即可。

#### 为什么需要限流

比如 Web 服务，对外 API ，这种类型的服务有以下几种可能导致机器被拖垮：

- 用户增长过快（这是好事😄）

- 因为某个热点事件（比如微博热搜）

- 竞争对象爬虫
- 恶意请求

这些情况都是无法预知的，不知道什么时候会有 10 倍甚至 20 倍的流量打进来，如果真碰上这种情况，扩容根本来不及。

<img src="assets/image-20251222215718898.png" alt="image-20251222215718898" style="zoom:50%;" />

从上图我们可以看出，对内而言：上游的 A、B 服务直接依赖了下游的基础服务 C，对于 A、B 服务都依赖的基础服务 C 这种场景，服务 A 和 B 其实处于某种竞争关系，如果服务 A 的并发阈值设置过大，当流量高峰期到来，有可能直接拖跨基础服务 C 并影响服务 B，也就是造成了<span style="color:#ff6e00;">雪崩效应</span>。

#### 限流算法

常见的限流算法有：

- 计数器算法
- 漏桶（Leaky Bucket）算法
- 令牌桶（Token Bucket）算法

##### 计数器算法

计数器算法是限流算法中最简单且最容易实现的一种算法。比如我们规定，对于 接口A 来说，我们 1 分钟内的访问次数不能超过 100 次。那么我们可以这么做：在一开始的时候，设置一个计数器 counter，每当一个请求过来的时候，counter 就加 1，如果 counter 的值大于 100 并且该请求与第一个请求的间隔还在 1 分钟之内，那么触发限流；如果该请求与第一个请求的间隔大于 1 分钟，重置 counter 重新计数，具体算法的示意图如下：

<img src="./assets/image-20241223211750996.png" alt="image-20241223211750996" style="zoom: 53%;" />

这个算法虽然简单，但是存在一个十分致命的问题，那就是临界值的问题，我们看下图：

 <img src="./assets/image-20241223211823709.png" alt="image-20241223211823709" style="zoom: 35%;" />

从上图我们可以看到，假设存在一个恶意的用户，在第 59 s 的时候，通过某种手段（比如：渗透测试）瞬间发送了 100 个请求，在 第 60 s （这个时候计数器已经被重置了）的时候又发送了 100个请求，相当于这个用户在 1s 时间内，瞬间发送了 200 个请求。一开始我们规定的是 1 分钟内最多 100个请求，也就是每秒最大 1.7 个请求，用户通过在时间窗口的重置节点处突发大量请求，可以瞬间超过我们的限流阈值。用户很有可能通过算法的这个漏洞，瞬间压垮我们的应用。

不仅如此，还存在资源浪费的问题，我们的预想算法是希望 100 个请求均匀的分散在 1 分钟内，假设 30s 内我们请求就达到上限了，剩下的半分钟内，服务器就处于闲置状态，比如下图：

<img src="./assets/image-20241223212658994.png" alt="image-20241223212658994" style="zoom: 30%;" />

##### 漏桶算法

漏桶算法其实也很简单，可以粗略的认为就是注水漏水的过程中，往桶中以任意速率流入税，以一定速率流出水，当水超过桶流量则丢弃，因为桶容量不变，保证了整体的速率。

<img src="assets/image-20251222220254736.png" alt="image-20251222220254736" style="zoom:70%;" />

漏桶算法通过队列机制实现，如下图：

<img src="./assets/image-20241223222215371.png" alt="image-20241223222215371" style="zoom: 50%;" />

但是漏桶算法也存在致命的问题，当各服务大量请求打进来，桶内流量堆积会造成网关压力巨大，一旦网关宕机，整个微服务系统将崩溃。

##### 令牌桶算法

令牌桶算法是对漏桶算法的一种改进，漏桶算法能够限制请求调用的速率，而令牌桶算法能够在限制调用的平均速率的同时还允许一定程度的突发调用。在令牌桶算法中，存在一个桶，用来存放固定数量的令牌。<span style="color:#ff6e00;">算法中存在一种机制，以一定速率往桶中放令牌，每次调用请求需要先获取令牌，只有拿到令牌，才有机会继续执行，否则选择等待可用的令牌、或者直接拒绝。</span>放令牌的这个动作是持续不断地进行的，如果桶中令牌达到上限，就丢弃令牌。

> **✨ 场景：** 
>
> 桶中一直有大量可用的令牌，这时候进来的请求能够直接拿到令牌执行。比如设置 QPS 为100/s，那么限流器初始化完成 1 s 后，桶内就已经有了 100 个令牌，等待服务启动完成对外提供服务时，该限流器可以抵挡瞬时 100 个请求。当桶中没有令牌，请求继续等待，最后相当于以一定速率执行。

Spring Cloud Zuul 内部使用的就是令牌桶算法，大概描述如下：

- 对所有的请求在处理之前都需要拿到一个可用的令牌才会被处理；
- 根据限流大小，设置按照一定的速率往桶里添加令牌；
- 桶设置最大的放置令牌限制，桶满时，新添加的令牌直接丢弃或被拒绝；
- 请求达到后首先要获取令牌桶中的令牌，拿着令牌才可以进行其他的业务逻辑处理，处理完业务逻辑之后，将令牌直接删除；
- <span style="color:#ff6e00;">令牌桶存在最低限额，当桶内令牌达到最低限额时，请求处理完后不会删除令牌，以保证足够的限流；</span>

如下图所示：

<img src="./assets/image-20241223223610164.png" alt="image-20241223223610164" style="zoom:67%;" />

通过对比我们可以看出，漏桶算法主要用途在于保护各个微服务组件，而令牌桶算法主要目的在于保护网关本身，将请求的压力交给目标服务自己去处理。假设突然进来很多请求，只有拿到令牌的请求才会瞬时被处理调用目标服务。

#### Zuul 限流实现

##### 通过 RateLimit 实现限流

###### 添加依赖

> RateLimit 官方文档：https://github.com/marcosbarbero/spring-cloud-zuul-ratelimit

Zuul 的限流保护需要额外引入 `spring-cloud-zuul-ratelimit` 组件，限流数据采用 Redis 存储，所以还需要添加 Redis 组件。

```xml
<dependency>
    <groupId>com.marcosbarbero.cloud</groupId>
    <artifactId>spring-cloud-zuul-ratelimit</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis-reactive</artifactId>
</dependency>
<dependency>
    <groupId>org.apache.commons</groupId>
    <artifactId>commons-pool2</artifactId>
</dependency>
```

###### 全局限流配置

使用全局限流配置，Zuul 对所有的服务提供限流保护。

```yaml
spring:
  redis:
    timeout: 10000 # 连接超时时间
    host: 117.24.15.104 # redis服务地址
    port: 6379 # redis服务端口
    password: redis_Fct28w # redis密码
    database: 0 # 选择哪一个库，默认0库
    lettuce:
      pool:
        max-active: 1024 # 最大连接数
        max-wait: 10000 #最大连接阻塞等待时间，单位 ms 默认 -1
        max-idle: 200 # 最大空闲连接
        min-idle: 5 # 最小空闲连接
# Zuul 网关核心配置
zuul:
  ratelimit:
    # 是否启用请求限流功能
    enabled: true
    # 限流策略类型，使用 Redis 存储限流数据
    repository: REDIS
    # 定义默认的限流规则
    default-policy-list:
      - limit: 5
        refresh-interval: 60 # 默认限流规则，1s 内请求超过 1000 次则限流
        type:
          - origin
          - url
          - user
```

只要我们在 1分钟内访问 http://127.0.0.1:30000/autumnnook-system/test/info 服务超过 5 次，就会触发限流。

![image-20251222225628671](assets/image-20251222225628671.png)

###### 局部限流配置

使用局部限流配置，Zuul 仅针对配置的服务提供限流保护。

```yaml
spring:
  redis:
    timeout: 10000 # 连接超时时间
    host: 117.24.15.104 # redis服务地址
    port: 6379 # redis服务端口
    password: redis_Fct28w # redis密码
    database: 0 # 选择哪一个库，默认0库
    lettuce:
      pool:
        max-active: 1024 # 最大连接数
        max-wait: 10000 #最大连接阻塞等待时间，单位 ms 默认 -1
        max-idle: 200 # 最大空闲连接
        min-idle: 5 # 最小空闲连接
# Zuul 网关核心配置
zuul:
  ratelimit:
    # 是否启用请求限流功能
    enabled: true
    # 限流策略类型，使用 Redis 存储限流数据
    repository: REDIS
    # 定义具体的限流规则
    policy-list:
      # 针对 autumnnook-system 服务的限流规则
      autumnnook-system:
        - limit: 5
          refresh-interval: 60 # 刷新间隔，单位秒，60s 内请求超过 5 次则限流
          type:
            - origin # 根据请求来源进行限流
            - url # 根据请求 URL 进行限流
            - user # 根据用户进行限流
```

只要我们在 1分钟内访问 http://127.0.0.1:30000/autumnnook-system/test/info 服务超过 5 次，就会触发限流。

![image-20251222225628671](assets/image-20251222225628671.png)

查看 Redis 验证令牌。

![image-20251222230401996](assets/image-20251222230401996.png)

###### 自定义限流策略

如果希望自己控制限流策略，可以通过自定义 `RateLimitKeyGenerator` 的实现来增加自己的策略逻辑。

🎯假设有这么一个场景，就是我们需要根据 id 去查询一个菜单的信息的时候，往往我们的业务接口大致会这么写：

```java
@GetMapping("/getMenuById")
public String getMenuById(String id) {
    return "return menu by id.";
}
```

这样就会导致一个问题就是假设某个菜单功能在某个时间段被用户大量使用，称为热门功能，就会导致触发限流，而一些冷门的菜单也会收到牵连。往往我们使用 RESTful 风格写法就可以避免这种问题，这是因为 url 始终是在变化的。

```java
@GetMapping("/{id}")
public String getMenuById(@PathVariable("id") String id) {
    return "return menu by id.";
}
```

因此为了避免这种 “误伤” 现象，我们就需要自定义我们的限流策略进行限流。

- 通过继承 `DefaultRateLimitKeyGenerator` 重写 `key()` 方法实现

```java
@Component
public class RateLimitGenerator extends DefaultRateLimitKeyGenerator {

    public RateLimitGenerator(RateLimitProperties properties, RateLimitUtils rateLimitUtils) {
        super(properties, rateLimitUtils);
    }

    @Override
    public String key(HttpServletRequest request, Route route, RateLimitProperties.Policy policy) {
        // 对请求参数中相同的 id 进行限流
        return super.key(request, route, policy) + ":" + request.getParameter("id");
    }

}
```

- 通过配置类实现（其实目的都一样）

```java
@Configuration
public class RateLimitGeneratorConfiguration {
    @Bean
    public RateLimitKeyGenerator rateLimitKeyGenerator(RateLimitProperties properties, RateLimitUtils rateLimitUtils) {
        return new DefaultRateLimitKeyGenerator(properties, rateLimitUtils) {
            @Override
            public String key(HttpServletRequest request, Route route, RateLimitProperties.Policy policy) {
                // 对请求参数中相同的 id 进行限流
                return super.key(request, route, policy) + ":" + request.getParameter("id");
            }
        };
    }
}
```

##### 通过 Sentinel 实现限流

Sentinel 支持对 Spring Cloud Gateway、Netflix Zuul 等主流的 API 网关进行限流。

<img src="assets/58381714-266d7980-7ff3-11e9-8617-d0d7c325d703.png" alt="sentinel-api-gateway-common-arch" style="zoom:50%;" />

官方文档：

- https://github.com/alibaba/spring-cloud-alibaba/wiki/Sentinel
- [https://github.com/alibaba/Sentinel/wiki/网关限流#zuul-1x](https://github.com/alibaba/Sentinel/wiki/网关限流#zuul-1x)

👉最新文档请参考 [https://sentinelguard.io/zh-cn/docs/api-gateway-flow-control.html](https://sentinelguard.io/zh-cn/docs/api-gateway-flow-control.html)

Sentinel 1.6.0 引入了 Sentinel API Gateway Adapter Common 模块，此模块中包含网关限流的规则和自定义 API 的实体和管理逻辑。

- <span style="color:#3370ff;font-weight:bold;">GatewayFlowRule：</span> 网关限流规则，针对 API Gateway 的场景定制的限流规则，可以针对不同 route 或自定义的 API 分组进行限流，支持针对请求中的参数、Header、来源 IP 等进行定制化的限流。
- <span style="color:#3370ff;font-weight:bold;">ApiDefinition：</span>用户自定义的 API 定义分组，可以看做是一些 URL 匹配的组合。比如我们可以定义一个 API 叫 `my_api`，请求 path 模式为 `/foo/**` 和 `/baz/**` 的都归到 `my_api` 这个 API 分组下面。限流的时候可以针对这个自定义的 API 分组维度进行限流。

其中网关限流规则  GatewayFlowRule 的字段解释如下：

- <span style="color:#3370ff;font-weight:bold;">resource：</span>资源名称，可以是网关中的 route 名称或者用户自定义的 API 分组名称。
- <span style="color:#3370ff;font-weight:bold;">resourceMode：</span>规则是针对 API Gateway 的 route（`RESOURCE_MODE_ROUTE_ID`）还是用户在 Sentinel 中定义的 API 分组（`RESOURCE_MODE_CUSTOM_API_NAME`），默认是 route。
- <span style="color:#3370ff;font-weight:bold;">grade：</span>限流指标维度，同限流规则的 `grade` 字段。
- <span style="color:#3370ff;font-weight:bold;">count：</span>限流阈值
- <span style="color:#3370ff;font-weight:bold;">intervalSec：</span>统计时间窗口，单位是秒，默认是 1 秒。
- <span style="color:#3370ff;font-weight:bold;">controlBehavior：</span>流量整形的控制效果，同限流规则的 `controlBehavior` 字段，目前支持快速失败和匀速排队两种模式，默认是快速失败。
- <span style="color:#3370ff;font-weight:bold;">burst：</span>应对突发请求时额外允许的请求数目。
- <span style="color:#3370ff;font-weight:bold;">maxQueueingTimeoutMs：</span>匀速排队模式下的最长排队时间，单位是毫秒，仅在匀速排队模式下生效。
- <span style="color:#3370ff;font-weight:bold;">paramItem：</span>参数限流配置。若不提供，则代表不针对参数进行限流，该网关规则将会被转换成普通流控规则；否则会转换成热点规则。其中的字段：
  - <span style="color:#7faff6;font-weight:bold;">parseStrategy：</span>从请求中提取参数的策略，目前支持提取来源 IP（`PARAM_PARSE_STRATEGY_CLIENT_IP`）、Host（`PARAM_PARSE_STRATEGY_HOST`）、任意 Header（`PARAM_PARSE_STRATEGY_HEADER`）和任意 URL 参数（`PARAM_PARSE_STRATEGY_URL_PARAM`）四种模式。
  - <span style="color:#7faff6;font-weight:bold;">fieldName：</span>若提取策略选择 Header 模式或 URL 参数模式，则需要指定对应的 header 名称或 URL 参数名称。
  - <span style="color:#7faff6;font-weight:bold;">pattern：</span>参数值的匹配模式，只有匹配该模式的请求属性值会纳入统计和流控；若为空则统计该请求属性的所有值。（1.6.2 版本开始支持）
  - <span style="color:#7faff6;font-weight:bold;">matchStrategy：</span>参数值的匹配策略，目前支持精确匹配（`PARAM_MATCH_STRATEGY_EXACT`）、子串匹配（`PARAM_MATCH_STRATEGY_CONTAINS`）和正则匹配（`PARAM_MATCH_STRATEGY_REGEX`）。（1.6.2 版本开始支持）

用户可以通过 `GatewayRuleManager.loadRules(rules)` 手动加载网关规则，或通过 `GatewayRuleManager.register2Property(property)` 注册动态规则源动态推送（推荐方式）。

###### 添加依赖

[参考 Sentinel 网关限流文档](https://github.com/alibaba/Sentinel/wiki/网关限流)

如果单独使用，只需要添加 `sentinel-zuul-adapter` 组件即可。

若想跟 Sentinel Starter 配合使用，需要加上 `spring-cloud-alibaba-sentinel-gateway` 依赖，同时需要添加 `spring-cloud-starter-netflix-zuul` 依赖来让 `spring-cloud-alibaba-sentinel-gateway` 模块里的 Zuul 自动化配置类生效：

```xml
<dependency>
    <groupId>com.alibaba.cloud</groupId>
    <artifactId>spring-cloud-starter-alibaba-sentinel</artifactId>
</dependency>

<dependency>
    <groupId>com.alibaba.cloud</groupId>
    <artifactId>spring-cloud-alibaba-sentinel-gateway</artifactId>
</dependency>

<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-zuul</artifactId>
</dependency>
```

同时请将 `spring.cloud.sentinel.filter.enabled` 配置项置为 false（若在网关流控控制台上看到了 URL 资源，就是此配置项没有置为 false）。Sentinel 网关流控默认的粒度是 route 维度以及自定义 API 分组维度，默认**不支持 URL 粒度**。如需细化到 URL 粒度，请参考 [网关流控文档](https://sentinelguard.io/zh-cn/docs/api-gateway-flow-control.html) 自定义 API 分组。

###### Zuul 1.x 单独使用

Sentinel 提供了 Zuul 1.x 的适配模块，可以为 Zuul Gateway 提供两种资源维度的限流：

- route 维度：即在 Spring 配置文件中配置的路由条目，资源名为对应的 route ID（对应 `RequestContext` 中的 `proxy` 字段）
- 自定义 API 维度：用户可以利用 Sentinel 提供的 API 来自定义一些 API 分组

使用时需引入以下模块（以 Maven 为例）：

```xml
<dependency>
    <groupId>com.alibaba.csp</groupId>
    <artifactId>sentinel-zuul-adapter</artifactId>
    <!--<version>x.y.z</version>-->
</dependency>
```

若使用的是 Spring Cloud Netflix Zuul，我们可以直接在配置类中将三个 filter 注入到 Spring 环境中即可：

```java
@Configuration
public class ZuulConfig {
    @Bean
    public ZuulFilter sentinelZuulPreFilter() {
        // We can also provider the filter order in the constructor.
        return new SentinelZuulPreFilter();
    }

    @Bean
    public ZuulFilter sentinelZuulPostFilter() {
        return new SentinelZuulPostFilter();
    }

    @Bean
    public ZuulFilter sentinelZuulErrorFilter() {
        return new SentinelZuulErrorFilter();
    }
    
    @PostConstruct
    public void init(){
        Set<GatewayFlowRule> rules = new HashSet<>();
        rules.add(new GatewayFlowRule("autumnnook-system")
                .setCount(3)//限流阈值
                .setIntervalSec(60));// 60s 内访问超过 3 次则限流，默认1s
        GatewayRuleManager.loadRules(rules);
    }
}
```

Sentinel Zuul Adapter 生成的调用链路类似于下面，其中的资源名都是 route ID 或者自定义的 API 分组名称：

```bash
-EntranceNode: sentinel_gateway_context$$route$$another-route-b(t:0 pq:0.0 bq:0.0 tq:0.0 rt:0.0 prq:0.0 1mp:8 1mb:1 1mt:9)
--another-route-b(t:0 pq:0.0 bq:0.0 tq:0.0 rt:0.0 prq:0.0 1mp:4 1mb:1 1mt:5)
--another_customized_api(t:0 pq:0.0 bq:0.0 tq:0.0 rt:0.0 prq:0.0 1mp:4 1mb:0 1mt:4)
-EntranceNode: sentinel_gateway_context$$route$$my-route-1(t:0 pq:0.0 bq:0.0 tq:0.0 rt:0.0 prq:0.0 1mp:6 1mb:0 1mt:6)
--my-route-1(t:0 pq:0.0 bq:0.0 tq:0.0 rt:0.0 prq:0.0 1mp:2 1mb:0 1mt:2)
--some_customized_api(t:0 pq:0.0 bq:0.0 tq:0.0 rt:0.0 prq:0.0 1mp:2 1mb:0 1mt:2)
```

发生限流之后的处理流程 ：

- 发生限流之后可自定义返回参数，通过实现 `SentinelFallbackProvider` 接口，默认的实现是 `DefaultBlockFallbackProvider`。
- 默认的 fallback route 的规则是 route ID 或自定义的 API 分组名称。

比如：

```java
// 自定义 FallbackProvider 
public class MyBlockFallbackProvider implements ZuulBlockFallbackProvider {

    private Logger logger = LoggerFactory.getLogger(DefaultBlockFallbackProvider.class);
    
    @Override
    public String getRoute() {
        return "/book/app";
    }

    @Override
    public BlockResponse fallbackResponse(String route, Throwable cause) {
        RecordLog.info(String.format("[Sentinel DefaultBlockFallbackProvider] Run fallback route: %s", route));
        if (cause instanceof BlockException) {
            return new BlockResponse(429, "Sentinel block exception", route);
        } else {
            return new BlockResponse(500, "System Error", route);
        }
    }
 }
 
 // 注册 FallbackProvider
 ZuulBlockFallbackManager.registerProvider(new MyBlockFallbackProvider());
```

默认情况下限流后会返回 429 状态码，返回结果为：

```json
{
    "code":429,
    "message":"Sentinel block exception",
    "route":"/"
}
```

**注意**：

- Sentinel 网关流控默认的粒度是 route 维度以及自定义 API 分组维度，默认**不支持 URL 粒度**。若通过 Spring Cloud Alibaba 接入，请将 `spring.cloud.sentinel.filter.enabled` 配置项置为 false（若在网关流控控制台上看到了 URL 资源，就是此配置项没有置为 false）。
- 若使用 Spring Cloud Alibaba Sentinel 数据源模块，需要注意网关流控规则数据源类型是 `gw-flow`，若将网关流控规则数据源指定为 flow 则不生效。

访问服务 http://localhost:30000/autumnnook-system/test/status 可以看到：

![image-20251223145604534](assets/image-20251223145604534.png)

###### 结合 Starter 使用

使用 starter 相关依赖，注释掉 `sentinel-zuul-adapter` 组件依赖。

```xml
<dependency>
    <groupId>com.alibaba.cloud</groupId>
    <artifactId>spring-cloud-starter-alibaba-sentinel</artifactId>
</dependency>
<dependency>
    <groupId>com.alibaba.cloud</groupId>
    <artifactId>spring-cloud-alibaba-sentinel-gateway</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-zuul</artifactId>
</dependency>
```

配置文件修改如下。

```yaml
spring:
  cloud:
    sentinel:
      filter:
        enabled: false
```

同样的添加 ZuulConfig 配置类，自定义限流阈值。

```java
@Configuration
public class ZuulConfig {
    @PostConstruct
    public void init(){
        Set<GatewayFlowRule> rules = new HashSet<>();
        rules.add(new GatewayFlowRule("autumnnook-system")
                .setCount(3)//限流阈值
                .setIntervalSec(60));// 60s 内访问超过 3 次则限流，默认1s
        GatewayRuleManager.loadRules(rules);
    }
}
```

访问服务 http://localhost:30000/autumnnook-system/test/status 可以看到：

![image-20251223150357626](assets/image-20251223150357626.png)

###### 自定义 Sentinel 限流异常（网关熔断）

发生限流之后的处理流程：

- 发生限流之后可自定义返回参数，通过实现 `ZuulBlockFallbackProvider` 接口，默认的实现是 `DefaultBlockFallbackProvier`；
- 默认的 fallback route 的规则是 route ID 或自定义的 API 分组名称；

1. 编写限流处理类-对具体服务进行容错处理

```java
import com.alibaba.csp.sentinel.adapter.gateway.zuul.fallback.BlockResponse;
import com.alibaba.csp.sentinel.adapter.gateway.zuul.fallback.ZuulBlockFallbackProvider;
import com.alibaba.csp.sentinel.log.RecordLog;
import com.alibaba.csp.sentinel.slots.block.BlockException;
public class ZuulFallbackProvider implements ZuulBlockFallbackProvider {
    @Override
    public String getRoute() {
        return "autumnnook-system";
    }
    @Override
    public BlockResponse fallbackResponse(String route, Throwable cause) {
        RecordLog.info(String.format("[Sentinel DefaultBlockFallbackProvider] Run fallback route: %s", route));
        if (cause instanceof BlockException) {
            return new BlockResponse(429, "服务访问压力过大，请稍后重试！", route);
        } else {
            return new BlockResponse(500, "系统错误，请联系管理员！", route);
        }
    }
}
```

2. 注册网关熔断提供者

```java
import com.alibaba.csp.sentinel.adapter.gateway.common.rule.GatewayFlowRule;
import com.alibaba.csp.sentinel.adapter.gateway.common.rule.GatewayRuleManager;
import com.alibaba.csp.sentinel.adapter.gateway.zuul.fallback.ZuulBlockFallbackManager;
import com.alibaba.csp.sentinel.adapter.gateway.zuul.filters.SentinelZuulErrorFilter;
import com.alibaba.csp.sentinel.adapter.gateway.zuul.filters.SentinelZuulPostFilter;
import com.alibaba.csp.sentinel.adapter.gateway.zuul.filters.SentinelZuulPreFilter;
import com.autumnnook.fallback.ZuulFallbackProvider;
import com.autumnnook.locator.SimpleRoutingLocater;
import com.netflix.zuul.ZuulFilter;
import lombok.RequiredArgsConstructor;
import org.springframework.boot.autoconfigure.web.ServerProperties;
import org.springframework.cloud.netflix.zuul.filters.SimpleRouteLocator;
import org.springframework.cloud.netflix.zuul.filters.ZuulProperties;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;
import javax.annotation.PostConstruct;
import java.util.HashSet;
import java.util.Set;
/**
 * Zuul网关配置类
 * <p>该类负责配置Zuul网关的核心组件，特别是自定义路由定位器的注册和初始化。
 * 通过替换默认的路由定位器，实现基于服务发现的动态路由管理。</p>
 * <p><b>主要功能：</b></p>
 * <ul>
 *   <li>配置自定义路由定位器Bean</li>
 *   <li>注入Zuul和服务器相关配置属性</li>
 *   <li>确保自定义路由定位器优先于默认实现</li>
 * </ul>
 * <p><b>配置说明：</b></p>
 * <ul>
 *   <li>使用{@link Configuration}标识为配置类</li>
 *   <li>使用{@link RequiredArgsConstructor}自动生成构造函数</li>
 *   <li>使用{@link Primary}确保自定义Bean优先被使用</li>
 * </ul>
 *
 * @author 蔡熙贝
 * @version 1.0
 * @see SimpleRoutingLocater
 * @see ZuulProperties
 * @see ServerProperties
 * @since 2024
 */
@Configuration
public class ZuulConfig {

    @PostConstruct
    public void init() {
        ZuulBlockFallbackManager.registerProvider(new ZuulFallbackProvider());
    }

}

```

重启 zuul 网关，访问 http://127.0.0.1:30000/autumnnook-system/test/status 多次，触发限流，可以看到：

![image-20251223151925530](assets/image-20251223151925530.png)

#### 网关限流错误处理

配置 `error` 类型的网关过滤器进行处理即可，修改之前的 `ErrorFilter` 让其变得通用。

```java
import com.netflix.zuul.ZuulFilter;
import com.netflix.zuul.context.RequestContext;
import com.netflix.zuul.exception.ZuulException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.cloud.netflix.zuul.util.ZuulRuntimeException;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Component;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.io.PrintWriter;
/**
 * 自定义 Zuul 网关过滤器 作用：实现请求级别的自定义处理逻辑，如日志记录、权限验证、参数校验等 生命周期：在请求经过 Zuul 网关时被调用，按照过滤器类型和顺序执行
 *
 * @author 蔡熙贝
 */
@Component
public class ErrorFilter extends ZuulFilter {

    private static final Logger logger = LoggerFactory.getLogger(ErrorFilter.class);

    /**
     * 过滤器类型定义 返回值必须是以下四种类型之一： - "pre":    前置过滤器，在请求路由到目标服务之前执行 典型用途：身份验证、日志记录、限流等 - "route":  路由过滤器，负责将请求路由到具体的微服务
     * 典型用途：HTTP请求转发、服务发现集成 - "post":   后置过滤器，在请求路由到目标服务之后执行 典型用途：响应头修改、统计信息收集、日志记录 - "error":  错误过滤器，当请求处理过程中发生错误时执行
     * 典型用途：错误处理、异常响应格式化
     *
     * @return 过滤器类型字符串
     */
    @Override
    public String filterType() {
        return "pre";
    }

    /**
     * 过滤器执行顺序 作用：当有多个同类型过滤器时，确定它们的执行顺序 规则：数值越小，优先级越高，执行越靠前 范围：可以是任意整数，通常使用 0, 1, 2, ... 等 示例： - 认证过滤器：order = 0（最先执行，验证身份） -
     * 日志过滤器：order = 1（其次执行，记录请求） - 参数校验过滤器：order = 2（最后执行，校验参数）
     *
     * @return 过滤器执行顺序的整数值
     */
    @Override
    public int filterOrder() {
        return 0;
    }

    /**
     * 是否启用该过滤器 作用：动态控制过滤器是否执行 返回值： - true:  执行该过滤器的 run() 方法 - false: 跳过该过滤器，不执行 run() 方法 应用场景： 1. 根据请求路径决定是否执行（如只对 /api/**
     * 路径生效） 2. 根据配置开关动态启用/禁用过滤器 3. 根据请求头或参数判断是否需要过滤
     *
     * @return 布尔值，表示是否执行该过滤器
     */
    @Override
    public boolean shouldFilter() {
        return true;
    }

    /**
     * 过滤器的核心业务逻辑 作用：实现具体的过滤处理逻辑 执行时机：当 shouldFilter() 返回 true 时被调用 关键对象： 1. RequestContext: Zuul 请求上下文，存储请求/响应信息 2.
     * HttpServletRequest: 原始 HTTP 请求对象 常用操作： 1. 获取请求信息：URL、方法、头信息、参数等 2. 修改请求：添加/删除请求头、修改请求参数 3. 中断请求：设置
     * context.setSendZuulResponse(false) 阻止转发 4. 设置响应：直接返回响应，不转发到后端服务
     *
     * @return 通常返回 null，特殊情况下可返回任意对象
     * @throws ZuulException 处理过程中可能抛出的异常
     */
    @Override
    public Object run() throws ZuulException {
        RequestContext rc = RequestContext.getCurrentContext();
        ZuulException exception = findZuulException(rc.getThrowable());
        logger.error("ErrorFilter caught an exception: {}", exception.errorCause, exception);
        HttpStatus status = null;
        if (429 == exception.nStatusCode) {
            status = HttpStatus.TOO_MANY_REQUESTS;
        }
        if (500 == exception.nStatusCode) {
            status = HttpStatus.INTERNAL_SERVER_ERROR;
        }
        rc.setResponseStatusCode(status.value());
        rc.getResponse().setContentType("application/json;charset=UTF-8");
        PrintWriter writer = null;
        try {
            writer = rc.getResponse().getWriter();
            writer.write("{\"code\":" + status.value() + ",\"message\":\"" + status.getReasonPhrase() + "\"}");
        } catch (IOException ex) {
            ex.printStackTrace();
        } finally {
            if (null != writer) {
                writer.close();
            }
        }
        return null;
    }

    private ZuulException findZuulException(Throwable throwable) {
        if (throwable.getCause() instanceof ZuulException) {
            return (ZuulException)throwable.getCause();
        }
        if (throwable.getCause() instanceof ZuulRuntimeException) {
            return (ZuulException)throwable.getCause();
        }
        return new ZuulException(throwable, HttpServletResponse.SC_INTERNAL_SERVER_ERROR, null);
    }
}
```

## 网关调优

使用 Zuul 的 Spring Cloud 微服务结构图。

<img src="assets/image-20251222234034873.png" alt="image-20251222234034873" style="zoom:57%;" />



从上面可以看出，整体请求逻辑还是很复杂的，在没有 zuul 网关的情况下，client 请求 service 的时候，也有请求超时的可能，那么当增加了 Zuul 网关的时候，请求超时的可能就会更加明显。

当请求通过 Zuul 网关路由到服务，并等待服务返回响应，这个过程中 Zuul 也有超时控制。Zuul 的底层使用的是 Hystrix + Ribbon 来实现请求路由。

<img src="assets/image-20251222234427027.png" alt="image-20251222234427027" style="zoom:54%;" />



Zuul 中的 Hystrix 内部使用线程池隔离机制提供请求路由实现，其默认的超时时长为 1000 ms，Ribbon 底层默认超时时长为 5000 ms。

- <span style="color:#e94242;">如果 Hystrix 超时，直接返回超时异常；</span>
- <span style="color:#e94242;">如果 Ribbon 超时，同时 Hystrix 未超时，Ribbon 会自动进行服务集群轮询重试，直到 Hystrix 超时为止；</span>
- <span style="color:#e94242;">如果 Hystrix 超时时长小于 Ribbon 超时时长，Ribbon 不会进行服务集群的轮询重试；</span>

### 添加依赖

Spring Cloud Netflix Zuul 网关重试机制需要使用 `spring-retry` 组件。

```xml
<dependency>
    <groupId>org.springframework.retry</groupId>
    <artifactId>spring-retry</artifactId>
</dependency>
```

### 配置文件

```yml
# Hystrix 熔断器配置
hystrix:
  command:
    default:
      execution:
        isolation:
          thread:
            # 线程池隔离策略下的线程池配置
            timeoutInMilliseconds: 10000 # 设置 Hystrix 命令的执行超时时间为 10 秒

# Ribbon 负载均衡器配置，建议小于 Hystrix 超时
ribbon:
  ConnectionTimeout: 5000 # 连接超时时间，单位毫秒
  ReadTimeout: 5000 # 读取超时时间，单位毫秒
  MaxAutoRetries: 1 # 最大自动重试次数
  MaxAutoRetriesNextServer: 1 # 切换到下一个服务器的最大重试次数
  OkToRetryOnAllOperations: true # 是否对所有操作进行重试
  
# Zuul 网关核心配置
zuul:
  retryable: true # 启用请求重试机制，提升请求成功率
```

### 启动类

启动类需要开启 `@EnableRetry` 重试注解。

```java
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.client.discovery.EnableDiscoveryClient;
import org.springframework.cloud.netflix.hystrix.EnableHystrix;
import org.springframework.cloud.netflix.hystrix.dashboard.EnableHystrixDashboard;
import org.springframework.cloud.netflix.zuul.EnableZuulProxy;
import org.springframework.context.ApplicationContext;
import org.springframework.core.env.Environment;
import org.springframework.retry.annotation.EnableRetry;
/**
 * Zuul 网关应用启动类
 * <p>该类是 AutumnNook 微服务架构中的 API 网关入口，负责统一的路由转发、
 * 服务发现、熔断降级和监控管理功能。</p>
 * <p><b>核心功能注解说明：</b></p>
 * <ul>
 *   <li>{@link EnableZuulProxy}：启用 Zuul 代理功能，提供动态路由和过滤器支持</li>
 *   <li>{@link EnableDiscoveryClient}：启用服务发现客户端，与注册中心交互</li>
 *   <li>{@link EnableHystrix}：启用 Hystrix 熔断器，提供服务的容错保护</li>
 *   <li>{@link EnableHystrixDashboard}：启用 Hystrix 仪表盘，提供熔断监控界面</li>
 *   <li>{@link SpringBootApplication}：Spring Boot 应用标准注解，包含组件扫描和自动配置</li>
 * </ul>
 * <p><b>应用架构定位：</b></p>
 * <ul>
 *   <li>作为微服务架构的统一入口网关</li>
 *   <li>负责请求路由和负载均衡</li>
 *   <li>提供统一的认证授权入口</li>
 *   <li>实现服务的熔断降级和限流保护</li>
 *   <li>收集和展示服务监控指标</li>
 * </ul>
 *
 * @author 蔡熙贝
 * @version 1.0
 * @see EnableZuulProxy
 * @see EnableDiscoveryClient
 * @see EnableHystrix
 * @since 2024
 */
@EnableRetry
@EnableHystrix                  // 启用 Hystrix 熔断器，提供服务的容错保护机制
@EnableZuulProxy                // 启用 Zuul 代理，提供动态路由、监控、弹性等功能
@SpringBootApplication          // Spring Boot 应用核心注解，包含配置、组件扫描等
@EnableDiscoveryClient          // 启用服务发现客户端，支持 Eureka、Consul 等注册中心
@EnableHystrixDashboard         // 启用 Hystrix 仪表盘，提供可视化的熔断器监控界面
public class ZuulApplication {

    /**
     * 日志记录器实例，用于输出应用启动和运行过程中的关键信息
     */
    private static final Logger logger = LoggerFactory.getLogger(ZuulApplication.class);

    /**
     * 应用主入口方法
     * <p><b>启动流程说明：</b></p>
     * <ol>
     *   <li>初始化 Spring 应用上下文，加载所有配置和 Bean</li>
     *   <li>启动内嵌的 Web 服务器（Undertow）</li>
     *   <li>注册到服务发现中心（Eureka）</li>
     *   <li>初始化 Zuul 路由配置和过滤器链</li>
     *   <li>启动 Hystrix 熔断器和监控仪表盘</li>
     *   <li>输出启动成功信息和关键配置参数</li>
     * </ol>
     * <p><b>关键配置输出：</b></p>
     * <ul>
     *   <li>服务端口：网关对外服务的端口号</li>
     *   <li>实例地址：当前实例在注册中心注册的地址</li>
     *   <li>服务发现配置：是否拉取和注册服务的开关状态</li>
     *   <li>注册中心地址：Eureka 服务器集群地址</li>
     *   <li>访问地址：应用启动后的可访问地址</li>
     *   <li>监控端点：Actuator 监控端点的访问地址</li>
     * </ul>
     *
     * @param args 命令行参数，可用于覆盖配置文件中的参数
     */
    public static void main(String[] args) {
        // 启动 Spring Boot 应用，返回应用上下文
        ApplicationContext context = SpringApplication.run(ZuulApplication.class, args);

        // 获取环境配置信息
        Environment environment = context.getEnvironment();

        // 从环境变量中读取关键配置信息
        String port = environment.getProperty("server.port");
        String fetchRegistry = environment.getProperty("eureka.client.fetch-registry");
        String registryWithEureka = environment.getProperty("eureka.client.register-with-eureka");
        String defaultZone = environment.getProperty("eureka.client.service-url.defaultZone");
        String hostname = environment.getProperty("eureka.instance.hostname");
        String preferIpAddress = environment.getProperty("eureka.instance.prefer-ip-address");

        // 输出应用启动成功信息和关键配置
        logger.info("========= AutumnNook Zuul started successfully =========");
        logger.info("🚀 服务端口：{}", port);
        logger.info("🏠 实例地址：{}", hostname);
        logger.info("📥 是否从注册中心拉取服务：{}", fetchRegistry);
        logger.info("📤 是否注册到注册中心：{}", registryWithEureka);
        logger.info("🔗 注册中心集群地址：{}", defaultZone);
        logger.info("🌐 是否优先使用服务器的IP地址：{}", preferIpAddress);
        logger.info("📊 访问地址：http://localhost:{}/", port);
        logger.info("👁️ 监控端点：http://localhost:{}/actuator", port);
        logger.info("========================================================");
    }

    static {
        // 注册 JVM 关闭钩子，确保应用优雅关闭
        Runtime.getRuntime().addShutdownHook(new Thread(() -> {
            logger.info("===================Autumnnook Zuul 正在关闭===================");
            logger.info("正在清理资源...");
            // 这里可以添加具体的资源清理逻辑，如：
            // - 关闭数据库连接池
            // - 释放 Redis 连接
            // - 从注册中心注销服务
            // - 停止后台线程等
            logger.info("资源清理完成，服务已关闭");
        }));
    }
}

```

## 高可用网关环境搭建

业内通常用多少个 9 来衡量网站的可用性，例如 QQ 的可用性是 4 个 9 ，就是说 QQ 能够保证在一年里，服务在 99.99% 的时间是可用的，只有 0.01% 的时间不可用，大约最多53分钟，这是十分牛逼的。

对于大多数网站来说，2个 9 是基本可用、3 个 9 就代表高可用、4 个 9 就是拥有自动恢复能力的高可用。

实现高可用的主要手段就是 数据的冗余备份和 服务故障转移，这两个手段具体可以怎么做，在网关中如何实现？主要针对以下几个方向：

- 集群部署
- 负载均衡
- 健康检查
- 节点自动重启
- 熔断
- 服务降级
- 接口重试

### Nginx + 网关集群实现高可用网关

<img src="./assets/image-20241224200645668.png" alt="image-20241224200645668" style="zoom: 50%;" />

#### 下载安装 Nginx

详见 [第8章 Nginx 实现 API 网关]()。

#### 配置网关集群

*nginx.conf*

```shell
worker_processes  1;
events {
    worker_connections  1024;
}

http {
    include       mime.types;
    default_type  application/octet-stream;
    
    sendfile        on;
    keepalive_timeout  65;

    # 配置网关集群
    upstream zuul {
		server 127.0.0.1:30000;
		server 127.0.0.1:30001;
    }

    server {
        listen       80;
        server_name  localhost;
        
        # nginx 将请求分发至网关集群
        location / {
			proxy_pass http://zuul;
        }
        
        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   html;
        }
    }
}
```

#### 验证高可用网关

我们把我们的网关服务打成  `jar`  包通过控制台修改参数  `-Dserver.port`  去启动，这样我就不需要再建一个模块去凑集群服务了，具体情况如下：

![image-20241224202710253](./assets/image-20241224202710253.png)

然后我们再启动 Nginx 服务，IDEA 中仅启动 注册中心和服务提供者：

![image-20241224202845465](./assets/image-20241224202845465.png)

打开 Postman 进行测试，模拟大量请求访问：

![image-20241224203008409](./assets/image-20241224203008409.png)

请求转发成功的情况如上所示，请求限流结果如下：

![image-20241224203056346](./assets/image-20241224203056346.png)















































































































