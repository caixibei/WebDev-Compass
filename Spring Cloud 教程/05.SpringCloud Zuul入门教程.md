Zuul 服务网关

## 学习目标

![image-20251211141511205](assets/image-20251211141511205.png)

## 什么是 Zuul

Zuul 是从设备和网站到应用程序后端的所有请求的前门。作为边缘服务应用程序，Zuul 旨在实现动态路由，监视，弹性和安全性。Zuul 包含了对请求的路由和过滤两个最主要的功能。

Zuul 是 Netflix 开源的微服务网关，它可以和 Eureka、Ribbon 、Hystrix 等组件配合使用。Zuul 的核心是一系列的过滤器，这些过滤器可以完成以下功能：

- 身份认证与安全：识别每个资源的验证要求，并拒绝那些与要求不符的请求；
- 审查与监控：在边缘位置追踪有意义的数据和统计结果，从而带来精确的生产试图；
- 动态路由：动态的将请求路由到不同的后端集群；
- 压力测试：逐渐增加指向集群的流量，以了解性能；
- 负载分配：为每一种负载类型分配对应容量，并弃用超出限定值的请求；
- 静态响应处理：在边缘位置直接建立部分响应，从而避免转发到内部集群；
- 多区域弹性：跨越 AWS Region 进行请求路由，旨在实现 ELB 使用的多样化，以及让系统的边缘更贴近系统的使用者；

## 什么是服务网关

API Gateway （APIGW / API 网关），故名思义，是出现在系统边界山歌的一个面向 API 的、串行集中式的强管控服务，这里的边界是企业 IT 系统的边界，可以理解为企业级应用防火墙，主要起到隔离外部访问与内部系统的作用。在微服务概念的流行之前，API 网关就已经诞生了，例如银行、证券等领域常见的前置机系统，也是解决访问认证、报文转换、访问统计等问题的。

API 网关的流行，源于近几年来移动应用与企业间互联网需求的兴起。移动应用、企业互联，使得后台服务支持的对象，从以前单一的 Web 应用，扩展到多种应用场景，且每种使用场景对后台服务的要求都不尽相同。这不仅增加了后台服务的响应量，还增加了后台服务的复杂性。随着微服务架构概念的提出，API 网关成为了微服务架构的一个标配组件。

API 网关是一个服务器，是系统对外的唯一入口。API 网关封装了系统内部架构，为每个客户端提供定制的 API 。所有的客户端和消费端都通过统一的网关接入微服务，在网关层处理所有的非业务功能。API 网关并不是微服务场景中必须的组件，如下图，不管有没有 API 网关，后端微服务都可以通过 API 很好的支持客户端的访问。

<img src="assets/image-20251220154549792.png" alt="image-20251220154549792" style="zoom:67%;" />

但对于服务数量众多，复杂度较高，规模比较大的业务来说，引入 API 网关也有一系列的好处：

- 聚合接口使得服务对调用者透明，客户端与后端的耦合度降低；
- 聚合后台服务，节省流量，提高性能，以提升用户体验；
- 提供安全、流控、过滤、缓存、计费、监控等 API 管理功能；

## 为什么要使用网关

Zuul 是 Netflix 开源的 API 网关，本质是一个 **反向代理 + 过滤器链** 的架构模式。它在不同架构中的价值体现有显著差异。

- 单体应用：浏览器发起请求到单体应用所在的机器，应用从数据库查询数据原路返回给浏览器，对于单体应用来说是不需要网关的。
- 微服务：微服务的应用可能部署在不同机房，不同地区，不同域名下。此时客户端（浏览器/手机/软件工具）想要请求对应的服务，都需要知道机器的具体 IP 地址 或者域名 URL，当微服务实例众多的时候，这是十分难以记忆的，对于客户端来说也太复杂难以维护。此时就有了网关，客户端相关的请求直接发送到网关，由网关根据请求标识解析判断出具体的微服务地址，再把请求转发到微服务实例。这其中的记忆功能就全部交给网关去操作了。

<img src="assets/image-20251220164718340.png" alt="image-20251220164718340" style="zoom:67%;" />



总的来说，如果让客户端直接与各微服务交互，会带来以下问题：

- 客户端会多次请求不同的微服务，增加了客户端的复杂性；
- 存在跨域请求问题，且在某些场景下处理相对复杂；
- 身份认证问题，每个微服务都需要独立的身份认证；
- 难以重构，随着项目的迭代，可能需要重新划分微服务；
- 某些微服务可能使用了防火墙/浏览器不友好的协议，直接访问存在一定的困难；

因此，为了解决这些问题，我们需要网关介于客户端与服务器之间的中间层，所有的外部请求率先经过微服务网关，客户端只需要与网关进行交互，只需要网关地址即可，这样便简化了开发且有以下优点。

- 易于监控，可在微服务网关收集监控数据并将其推送到外部系统进行分析；
- 易于认证，可在微服务网关上进行认证，然后再将请求转发到后端的微服务，从而无需在每个微服务中进行认证；
- 减少了客户端与各微服务之间的交互次数；

## 网关解决了什么问题

<img src="assets/image-20251220172914409.png" alt="image-20251220172914409" style="zoom:67%;" />

网关具有身份认证与安全、审查与监控、动态路由、负载均衡、缓存、请求分片与管理、静态响应处理等功能。当然最主要的职责还是 “与外界联系”。

总结来说，网关应该具有以下功能：

- 性能：API 高可用，负载均衡，容错机制；
- 安全：权限身份认证、脱敏、流量清洗、后端签名（保证全链路可信调用）、黑名单（非法调用限制）；
- 日志：日志记录，一旦设计分布式，全链路跟踪必不可少；
- 缓存：数据缓存；
- 监控：记录请求响应数据，API 耗时分析，性能监控；
- 限流：流量控制、错峰流控，可以定义多种限流规则；
- 灰度：线上灰度部署，可以减少风险；
- 路由：动态路由规则；

## 常用网关解决方案

### Nginx + Lua脚本

Nginx 是由 IgorSysoev 为俄罗斯访问量第二的 Rmbler.ru 站点开发的，一个高性能的 HTTP 和反向代理服务器，一方面可以做反向代理，另一方面可以做静态资源服务器。

🎯 Nginx 和 Zuul 有以下几个区别：

- Nginx 是 C 语言开发的，而 Zuul 是 Java 语言开发；
- Nginx 负载均衡实现是采用服务器实现负载均衡，而 Zuul 负载均衡的实现采用 Ribbon + Eureka 来实现本地负载均衡；
- Nginx 适合于服务器端负载均衡，Zuul 适合微服务中实现网关；
- Nginx 相比于 Zuul 功能会更加强大，因为 Nginx 可以整合一些脚本语言（Nginx + Lua 脚本）；
- Nginx 是一个高性能的 HTTP 和反向代理服务器，也是一个 IMAP / POP3 / SMIP 服务器。Zuul 是 Spring Cloud Netflix 中的开源的一个 API Gateway 服务器，本质上是一个 Servlet 应用，提供了动态路由、监控、弹性、安全等边缘服务的框架。Zuul 相当于是从设备到网站应用程序后端的所有请求的前门。

-   Nginx 适合做门户网关，是作为整个全局的网关，对外的处于最外层的那种；而 Zuul 属于业务网关，主要用来对应不同的客户端提供服务，用于聚合业务。各微服务独立部署，职责单一，对外提供服务的时候需要有一个东西将业务聚合起来；
-   Zuul 可以实现熔断、重试等功能，这是 Nginx 不具备的。

### Kong

Kong 是 Mashape 提供的一款 API 管理软件，本身是基于 Nginx + Lua 的，但比 Nginx 提供了更为简单的配置方式，数据采用了 ApacheCassandra / PostgreSQL 存储，并且提供了一些优秀的插件，比如验证，日志，调用频次限制等。Kong 非常诱人的地方就是提供了大量的插件来扩展应用，通过设置不同的插件可以为服务提供各种增强的功能。

🎯 具备以下优缺点：

-   优点：基于 Nginx 所以在性能和稳定性方面不会有问题。Kong 作为一款商业软件，在 Nginx 上做了很多的扩展性工作，并且还有很多付费使用的商业插件。Kong 本身也有付费的企业版，其中包括技术支持、使用培训服务以及 API 分析插件。
-   缺点：如果你使用 Spring Cloud , Kong 如何结合目前已有的服务治理体系？

### Traefik

Traefik 是一个开源的 Go 语言开发的，为了让微服务部署更加便捷而诞生的现代 HTTP 反向代理、负载均衡工具。它支持多种后台（Docker、Swarm、Kubernates、Marathon、Mesos、Consul、Etcd、Zookeeper、BoltDB、Rest API 等）来自动化、动态的应用他的配置文件设置，Traefik 拥有一个基于 AngularJS 编写的简单网站界面，支持 RestAPI，配置文件热更新，无需重启进程。高可用集群模式等。

🎯 相比 Spring Cloud 和 Kubernetes 而言，目前比较适合 Kubernetes 。

### SpringCloud Netflix Zuul

Zuul 是Netflix 公司开源的一个 API 网关组件，Spring Cloud 对其进行二次基于 Spring Boot 的注解式封装做到开箱即用。目前来说，结合 Spring Cloud 提供的服务治理体系，可以做到请求转发，根据配置或者默认的路由规则进行路由和负载均衡，无缝集成 Hystrix 。

虽然可以通过自定义 Filter 过滤器实现我们想要的功能，但是由于 Zuul 本身的涉及是基于 单线程的接收请求和转发处理，是阻塞 IO，不支持长连接。目前来看 Zuul 就显得很鸡肋，随着 Zuul 2.x 版本一致跳票 （2019年5月发布了 Zuul 2.0 版本），Spring Cloud 为了保险起见，推出了自己的 Spring Cloud Gateway。

<span style="color:darkgrey;font-size:12px;">大意就是：Zuul 已死，Spring Cloud Gateway 永生！🐶</span>

#### Zuul 1.0

<img src="./assets/image-20241210234005117.png" alt="架构图" style="zoom: 67%;" />

<img src="./assets/image-20241210234107613.png" alt="核心类图" style="zoom: 67%;" />

<img src="./assets/image-20241210234215051.png" alt="模型" style="zoom:95%;" />

#### Zuul 2.0

![image-20241210234349976](./assets/image-20241210234349976.png)

### SpringCloud Gateway

Spring Cloud Gateway 的工作原理：

![image-20241210234610441](./assets/image-20241210234610441.png)

客户端向 Spring Cloud Gateway 发出请求。如果网关处理程序映射确定请求与路由匹配，则会将其发送到网关 Web 处理程序。此处理程序通过特定于请求的筛选条件链运行请求。过滤器被虚线划分的原因是 filter 可以在发送代理请求之前和之后运行 logic。执行所有 “pre” filter logic。然后发出代理请求。发出代理请求后，将运行 “post” 筛选条件逻辑。

## Zuul 环境准备

我们新建一个微服务的项目，项目结构大致如下图所示。

![image-20251220195034652](assets/image-20251220195034652.png)

- Eureka 注册中心：提供服务发现和注册功能；
- Zuul 网关：提供动态路由功能；
- 模块 A：测试服务；
- 模块 B：测试服务；

![image-20251220232439113](assets/image-20251220232439113.png)

## Nginx 实现 API 网关

<img src="assets/image-20251221004038830.png" alt="image-20251221004038830" style="zoom: 35%;" />

在之前的课程中我们已经详细的讲解了 Nginx 关于反向代理、负载均衡等功能的使用，这里不再赘述。主要通过 Nginx 来实现 API 网关方便大家更好的学习和理解 Zuul 的使用。

### 下载安装

在这之前我们需要前往 [https://nginx.org/en/download.html](https://nginx.org/en/download.html) 下载 Nginx 服务器软件：

![image-20241211154334985](./assets/image-20241211154334985.png)

下载完成后解压到指定路径下 <span style="color:#ff6e00;">（不要放中文路径下！！！）</span>：

<img src="./assets/image-20241211154456228.png" alt="image-20241211154456228" style="zoom:95%;" />

双击启动  `nginx.exe`  程序，然后访问 [http://127.0.0.1:80/](http://127.0.0.1:80/) ，如果启动成功，页面如下所示：

![image-20241211154724058](./assets/image-20241211154724058.png)

打开配置文件  `conf\nginx.conf`  ，默认配置如下：

```bash
worker_processes  1;
events {
    worker_connections  1024;
}
http {
    include       mime.types;
    default_type  application/octet-stream;
    sendfile        on;
    keepalive_timeout  65;
    server {
    	# 监听端口 80
        listen       80;
        server_name  localhost;
        
        # 资源路径
        location / {
            root   html;
            index  index.html index.htm;
        }
        
        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   html;
        }
    }
}
```

### 配置路由规则

```bash
worker_processes  1;
events {
    worker_connections  1024;
}
http {
    include       mime.types;
    default_type  application/octet-stream;
    sendfile        on;
    keepalive_timeout  65;
    server {
    	# 监听端口 80
        listen       80;
        server_name  localhost;
        
        # 资源路径
        location / {
            root   html;
            index  index.html index.htm;
        }
        
        # 路由到 autumnnook-system 模块
        location /system/ {
        	proxy_pass http://127.0.0.1:18080/;
        }

        # 路由到 autumnnook-menu 模块
        location /menu/ {
        	proxy_pass http://127.0.0.1:18081/;
        }
        
        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   html;
        }
    }
}
```

我们来看下 Eureka 中注册的服务列表，当我们访问  `/system`  的时候，就将它路由到  `http://127.0.0.1/18080/` 。同样的，当我们访问  `/menu` 的时候，路由到  `http://127.0.0.1:18081/` 。

![image-20251221003503166](assets/image-20251221003503166.png)

在任务管理器中关闭 Nginx 进程后再次重启，以让配置文件生效后，访问 http://127.0.0.1/system/test/info ，如下所示，成功访问 system 模块的服务，说明路由转发成功了。

![image-20251221003834009](assets/image-20251221003834009.png)



## Zuul 实现 API 网关入门案例

### 搭建网关服务

#### 创建项目

创建 `autumnnook-zuul  `项目模块

![image-20251221005040072](assets/image-20251221005040072.png)

#### 添加项目依赖

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-zuul</artifactId>
</dependency>
<!--...其他依赖配置不做展示-->
```

#### 配置文件

```yaml
# Zuul 网关应用配置文件
#
# 该配置文件定义了 Zuul API 网关的核心配置，包括服务器设置、Spring 应用配置、
# Zuul 网关特性和 Eureka 服务发现配置。
#
# 主要功能：
# - 配置网关服务器参数和性能优化
# - 定义 Zuul 路由和负载均衡行为
# - 配置服务注册与发现（Eureka）
# - 设置健康检查和监控端点
#
# 适用场景：
# - 微服务架构中的 API 网关
# - 服务路由和负载均衡
# - 请求过滤和权限控制
# - 服务注册发现和健康监控
server:
  # 服务器端口配置
  port: ${SERVER_PORT:30000}
  # Undertow 服务器性能优化配置
  # Undertow 是高性能的 NIO 服务器，适用于高并发场景
  undertow:
    # I/O 线程数，负责处理非阻塞 I/O 操作
    # 建议设置为 CPU 核心数的 1-2 倍
    io-threads: 16
    # 工作线程数，负责处理业务逻辑
    # 根据业务复杂度和并发量调整，通常设置为 I/O 线程数的 10-100 倍
    worker-threads: 1600
    # 是否使用直接内存缓冲区
    # true 表示使用堆外内存，减少 GC 压力，提高性能
    direct-buffers: true
  # Servlet 上下文路径配置
  # 定义应用访问的基础路径，所有请求都需要包含此路径
  servlet:
    context-path: /
spring:
  # 应用名称配置，用于服务注册和发现
  # 在 Eureka 中以此名称注册服务
  application:
    name: ${APPLICATION_NAME:autumnnook-zuul}
  # Spring MVC 配置
  mvc:
    # 当没有找到请求处理器时是否抛出异常
    # true: 抛出 NoHandlerFoundException，便于统一异常处理
    # false: 返回默认 404 页面
    throw-exception-if-no-handler-found: true
  # 静态资源映射配置
  resources:
    # 是否启用静态资源映射
    # true: 启用，可以访问静态资源文件
    # false: 禁用，适用于纯 API 网关场景
    add-mappings: false
# Zuul 网关核心配置
zuul:
  # 信号量配置，用于控制并发请求数量
  semaphore:
    # 最大信号量数量，限制同时处理的请求数
    # 防止网关被过多请求压垮，起到熔断保护作用
    max-semaphores: 1100
  # 敏感请求头配置
  # 空数组表示不过滤任何请求头，所有头信息都会转发到下游服务
  sensitive-headers:
  # 是否剥离路由前缀
  # false: 保留完整路径转发到下游服务
  # true: 去除路由匹配的前缀部分
  strip-prefix: false
  # 是否添加 Host 头信息
  # true: 在转发请求时添加 Host 头，便于下游服务识别请求来源
  add-host-header: true
  # HTTP 客户端连接池配置
  host:
    # 最大总连接数，限制网关与所有下游服务的总连接数
    maxTotalConnections: 10000
    # 每个路由的最大连接数，限制到单个服务的最大连接数
    maxPerRouteConnections: 1100
    # Socket 超时时间（毫秒）
    # 设置与下游服务建立连接的超时时间
    socket-timeout-millis: 3600000
  # 是否忽略安全相关的响应头
  # false: 保留安全头信息（如 X-Content-Type-Options 等）
  ignoreSecurityHeaders: false
# Eureka 客户端配置
# 用于服务注册发现，网关需要注册到 Eureka 并发现其他服务
eureka:
  # 实例配置，定义当前服务实例的注册信息
  instance:
    # 实例主机名，用于服务发现时的地址解析
    hostname: ${HOSTNAME:${spring.application.name}}
    # 是否优先使用 IP 地址进行注册
    # false: 使用主机名注册
    # true: 使用 IP 地址注册，适用于容器化部署
    prefer-ip-address: ${PREFER_IP_ADDRESS:false}
    # 实例 ID 格式，在 Eureka 服务器中唯一标识此实例
    instance-id: ${spring.application.name}:${HOSTNAME:localhost}:${server.port}
    # 心跳续约间隔（秒）
    # 客户端向 Eureka 服务器发送心跳的频率
    lease-renewal-interval-in-seconds: ${LEASE_RENEWAL_INTERVAL_IN_SECONDS:10}
    # 租约过期时间（秒）
    # Eureka 服务器在多久没有收到心跳后认为实例下线
    lease-expiration-duration-in-seconds: 30
    # 状态页面 URL，用于展示实例状态信息
    status-page-url: http://${HOSTNAME:localhost}:${server.port}/actuator/info
    # 健康检查 URL，Eureka 服务器定期检查实例健康状态
    health-check-url: http://${HOSTNAME:localhost}:${server.port}/actuator/health
    # 主页 URL，实例的主页地址
    home-page-url: http://${HOSTNAME:localhost}:${server.port}
  # Eureka 客户端行为配置
  client:
    # 是否启用健康检查
    healthcheck:
      enabled: true
    # 是否从 Eureka 服务器获取注册表信息
    # true: 获取其他服务注册信息，用于服务发现
    fetch-registry: ${FETCH_REGISTRY:true}
    # 是否注册到 Eureka 服务器
    # true: 将本实例注册到 Eureka，供其他服务发现
    register-with-eureka: ${REGISTER_WITH_EUREKA:true}
    # Eureka 服务器地址配置
    service-url:
      # Eureka 服务器集群地址，支持多个地址用逗号分隔
      # 格式：协议://用户名:密码@主机名:端口/eureka/
      defaultZone: ${EUREKA_PEERS:http://soaadmin:jsepc01!@autumnnook-eureka:8761/eureka/}
```

#### 启动类

启动类需要添加 `@EnableZuulProxy` 注解（其余注解配置可以忽视，展示出来的比较全）

```java
package com.autumnnook;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.client.discovery.EnableDiscoveryClient;
import org.springframework.cloud.netflix.hystrix.EnableHystrix;
import org.springframework.cloud.netflix.hystrix.dashboard.EnableHystrixDashboard;
import org.springframework.cloud.netflix.zuul.EnableZuulProxy;
import org.springframework.context.ApplicationContext;
import org.springframework.core.env.Environment;

/**
 * Zuul 网关应用启动类
 * <p>该类是 AutumnNook 微服务架构中的 API 网关入口，负责统一的路由转发、
 * 服务发现、熔断降级和监控管理功能。</p>
 * <p><b>核心功能注解说明：</b></p>
 * <ul>
 *   <li>{@link EnableZuulProxy}：启用 Zuul 代理功能，提供动态路由和过滤器支持</li>
 *   <li>{@link EnableDiscoveryClient}：启用服务发现客户端，与注册中心交互</li>
 *   <li>{@link EnableHystrix}：启用 Hystrix 熔断器，提供服务的容错保护</li>
 *   <li>{@link EnableHystrixDashboard}：启用 Hystrix 仪表盘，提供熔断监控界面</li>
 *   <li>{@link SpringBootApplication}：Spring Boot 应用标准注解，包含组件扫描和自动配置</li>
 * </ul>
 * <p><b>应用架构定位：</b></p>
 * <ul>
 *   <li>作为微服务架构的统一入口网关</li>
 *   <li>负责请求路由和负载均衡</li>
 *   <li>提供统一的认证授权入口</li>
 *   <li>实现服务的熔断降级和限流保护</li>
 *   <li>收集和展示服务监控指标</li>
 * </ul>
 *
 * @author 蔡熙贝
 * @version 1.0
 * @see EnableZuulProxy
 * @see EnableDiscoveryClient
 * @see EnableHystrix
 * @since 2024
 */
@EnableHystrix                  // 启用 Hystrix 熔断器，提供服务的容错保护机制
@EnableZuulProxy                // 启用 Zuul 代理，提供动态路由、监控、弹性等功能
@SpringBootApplication          // Spring Boot 应用核心注解，包含配置、组件扫描等
@EnableDiscoveryClient          // 启用服务发现客户端，支持 Eureka、Consul 等注册中心
@EnableHystrixDashboard         // 启用 Hystrix 仪表盘，提供可视化的熔断器监控界面
public class ZuulApplication {

    /**
     * 日志记录器实例，用于输出应用启动和运行过程中的关键信息
     */
    private static final Logger logger = LoggerFactory.getLogger(ZuulApplication.class);

    /**
     * 应用主入口方法
     * <p><b>启动流程说明：</b></p>
     * <ol>
     *   <li>初始化 Spring 应用上下文，加载所有配置和 Bean</li>
     *   <li>启动内嵌的 Web 服务器（Undertow）</li>
     *   <li>注册到服务发现中心（Eureka）</li>
     *   <li>初始化 Zuul 路由配置和过滤器链</li>
     *   <li>启动 Hystrix 熔断器和监控仪表盘</li>
     *   <li>输出启动成功信息和关键配置参数</li>
     * </ol>
     * <p><b>关键配置输出：</b></p>
     * <ul>
     *   <li>服务端口：网关对外服务的端口号</li>
     *   <li>实例地址：当前实例在注册中心注册的地址</li>
     *   <li>服务发现配置：是否拉取和注册服务的开关状态</li>
     *   <li>注册中心地址：Eureka 服务器集群地址</li>
     *   <li>访问地址：应用启动后的可访问地址</li>
     *   <li>监控端点：Actuator 监控端点的访问地址</li>
     * </ul>
     *
     * @param args 命令行参数，可用于覆盖配置文件中的参数
     */
    public static void main(String[] args) {
        // 启动 Spring Boot 应用，返回应用上下文
        ApplicationContext context = SpringApplication.run(ZuulApplication.class, args);

        // 获取环境配置信息
        Environment environment = context.getEnvironment();

        // 从环境变量中读取关键配置信息
        String port = environment.getProperty("server.port");
        String fetchRegistry = environment.getProperty("eureka.client.fetch-registry");
        String registryWithEureka = environment.getProperty("eureka.client.register-with-eureka");
        String defaultZone = environment.getProperty("eureka.client.service-url.defaultZone");
        String hostname = environment.getProperty("eureka.instance.hostname");
        String preferIpAddress = environment.getProperty("eureka.instance.prefer-ip-address");

        // 输出应用启动成功信息和关键配置
        logger.info("========= AutumnNook Zuul started successfully =========");
        logger.info("🚀 服务端口：{}", port);
        logger.info("🏠 实例地址：{}", hostname);
        logger.info("📥 是否从注册中心拉取服务：{}", fetchRegistry);
        logger.info("📤 是否注册到注册中心：{}", registryWithEureka);
        logger.info("🔗 注册中心集群地址：{}", defaultZone);
        logger.info("🌐 是否优先使用服务器的IP地址：{}", preferIpAddress);
        logger.info("📊 访问地址：http://localhost:{}/", port);
        logger.info("👁️ 监控端点：http://localhost:{}/actuator", port);
        logger.info("========================================================");
    }

    static {
        // 注册 JVM 关闭钩子，确保应用优雅关闭
        Runtime.getRuntime().addShutdownHook(new Thread(() -> {
            logger.info("===================Autumnnook Zuul 正在关闭===================");
            logger.info("正在清理资源...");
            // 这里可以添加具体的资源清理逻辑，如：
            // - 关闭数据库连接池
            // - 释放 Redis 连接
            // - 从注册中心注销服务
            // - 停止后台线程等
            logger.info("资源清理完成，服务已关闭");
        }));
    }
}
```

### 配置路由规则

#### URL 地址路由

```yml
zuul:
  routes:
    autumnnook-system: # 路由 id 自定义
      path: /api/system/** # 配置请求 url 的映射路径
      url: http://autumnnook-system:18080 # 映射路径对应的微服务地址
    autumnnook-menu:
      path: /api/menu/**
      url: http://autumnnook-menu:18081
```

可以使用通配符，含义如下。

| 通配符 |             含义             |      举例      |                     解释                     |
| :----: | :--------------------------: | :------------: | :------------------------------------------: |
|   ?    |       匹配任意单个字符       | /api/system/?  |      /api/system/a，/api/system/b，...       |
|   *    | 匹配任意数量字符不包括子路径 | /api/system/*  |     /api/system/aa，/api/system/bbb，...     |
|   **   |  匹配任意数量字符包括子路径  | /api/system/** | /api/system/aa/bb，/api/system/bbb/cccc，... |

重启服务，访问结果如下：

![image-20251221010848379](assets/image-20251221010848379.png)

#### 服务名称路由

微服务一般由几十、上百个服务组成，对于 URL 地址路由的方式，如果对于每个服务实例手动指定一个唯一访问的地址，这样做显然是不合理的。

Zuul 支持与 Eureka 整合开发，根据 serviceId 自动从注册中心获取服务地址并转发请求，这样做的好处不仅可以通过单个端点来访问应用的所有服务，而且在添加或者移除服务时不用修改 Zuul 的路由配置。

##### 添加 Eureka Client 依赖

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
</dependency>
```

##### 配置注册中心和路由规则

```yml
# Zuul 网关应用配置文件
#
# 该配置文件定义了 Zuul API 网关的核心配置，包括服务器设置、Spring 应用配置、
# Zuul 网关特性和 Eureka 服务发现配置。
#
# 主要功能：
# - 配置网关服务器参数和性能优化
# - 定义 Zuul 路由和负载均衡行为
# - 配置服务注册与发现（Eureka）
# - 设置健康检查和监控端点
#
# 适用场景：
# - 微服务架构中的 API 网关
# - 服务路由和负载均衡
# - 请求过滤和权限控制
# - 服务注册发现和健康监控
server:
  # 服务器端口配置
  port: ${SERVER_PORT:30000}
  # Undertow 服务器性能优化配置
  # Undertow 是高性能的 NIO 服务器，适用于高并发场景
  undertow:
    # I/O 线程数，负责处理非阻塞 I/O 操作
    # 建议设置为 CPU 核心数的 1-2 倍
    io-threads: 16
    # 工作线程数，负责处理业务逻辑
    # 根据业务复杂度和并发量调整，通常设置为 I/O 线程数的 10-100 倍
    worker-threads: 1600
    # 是否使用直接内存缓冲区
    # true 表示使用堆外内存，减少 GC 压力，提高性能
    direct-buffers: true
  # Servlet 上下文路径配置
  # 定义应用访问的基础路径，所有请求都需要包含此路径
  servlet:
    context-path: /
spring:
  # 应用名称配置，用于服务注册和发现
  # 在 Eureka 中以此名称注册服务
  application:
    name: ${APPLICATION_NAME:autumnnook-zuul}
  # Spring MVC 配置
  mvc:
    # 当没有找到请求处理器时是否抛出异常
    # true: 抛出 NoHandlerFoundException，便于统一异常处理
    # false: 返回默认 404 页面
    throw-exception-if-no-handler-found: true
  # 静态资源映射配置
  resources:
    # 是否启用静态资源映射
    # true: 启用，可以访问静态资源文件
    # false: 禁用，适用于纯 API 网关场景
    add-mappings: false
# Zuul 网关核心配置
zuul:
  routes:
    autumnnook-system:
      path: /api/system/**
      service-id: ${AUTUMNLOOK_SYSTEM_SERVICE_ID:autumnnook-system}
    autumnnook-menu:
      path: /api/menu/**
      service-id: ${AUTUMNLOOK_MENU_SERVICE_ID:autumnnook-menu}
  # 信号量配置，用于控制并发请求数量
  semaphore:
    # 最大信号量数量，限制同时处理的请求数
    # 防止网关被过多请求压垮，起到熔断保护作用
    max-semaphores: 1100
  # 敏感请求头配置
  # 空数组表示不过滤任何请求头，所有头信息都会转发到下游服务
  sensitive-headers:
  # 是否剥离路由前缀
  # false: 保留完整路径转发到下游服务
  # true: 去除路由匹配的前缀部分
  strip-prefix: false
  # 是否添加 Host 头信息
  # true: 在转发请求时添加 Host 头，便于下游服务识别请求来源
  add-host-header: true
  # HTTP 客户端连接池配置
  host:
    # 最大总连接数，限制网关与所有下游服务的总连接数
    maxTotalConnections: 10000
    # 每个路由的最大连接数，限制到单个服务的最大连接数
    maxPerRouteConnections: 1100
    # Socket 超时时间（毫秒）
    # 设置与下游服务建立连接的超时时间
    socket-timeout-millis: 3600000
  # 是否忽略安全相关的响应头
  # false: 保留安全头信息（如 X-Content-Type-Options 等）
  ignoreSecurityHeaders: false
# Eureka 客户端配置
# 用于服务注册发现，网关需要注册到 Eureka 并发现其他服务
eureka:
  # 实例配置，定义当前服务实例的注册信息
  instance:
    # 实例主机名，用于服务发现时的地址解析
    hostname: ${HOSTNAME:${spring.application.name}}
    # 是否优先使用 IP 地址进行注册
    # false: 使用主机名注册
    # true: 使用 IP 地址注册，适用于容器化部署
    prefer-ip-address: ${PREFER_IP_ADDRESS:false}
    # 实例 ID 格式，在 Eureka 服务器中唯一标识此实例
    instance-id: ${spring.application.name}:${HOSTNAME:localhost}:${server.port}
    # 心跳续约间隔（秒）
    # 客户端向 Eureka 服务器发送心跳的频率
    lease-renewal-interval-in-seconds: ${LEASE_RENEWAL_INTERVAL_IN_SECONDS:10}
    # 租约过期时间（秒）
    # Eureka 服务器在多久没有收到心跳后认为实例下线
    lease-expiration-duration-in-seconds: 30
    # 状态页面 URL，用于展示实例状态信息
    status-page-url: http://${HOSTNAME:localhost}:${server.port}/actuator/info
    # 健康检查 URL，Eureka 服务器定期检查实例健康状态
    health-check-url: http://${HOSTNAME:localhost}:${server.port}/actuator/health
    # 主页 URL，实例的主页地址
    home-page-url: http://${HOSTNAME:localhost}:${server.port}
  # Eureka 客户端行为配置
  client:
    # 是否启用健康检查
    healthcheck:
      enabled: true
    # 是否从 Eureka 服务器获取注册表信息
    # true: 获取其他服务注册信息，用于服务发现
    fetch-registry: ${FETCH_REGISTRY:true}
    # 是否注册到 Eureka 服务器
    # true: 将本实例注册到 Eureka，供其他服务发现
    register-with-eureka: ${REGISTER_WITH_EUREKA:true}
    # Eureka 服务器地址配置
    service-url:
      # Eureka 服务器集群地址，支持多个地址用逗号分隔
      # 格式：协议://用户名:密码@主机名:端口/eureka/
      defaultZone: ${EUREKA_PEERS:http://soaadmin:jsepc01!@autumnnook-eureka:8761/eureka/}
```

#### 如何简化路由配置

Zuul 为了方便大家使用，提供了默认路由配置：路由 id 和 微服务名称一致，path 默认对应 `微服务名称/**` ，因此以下配置就不必再写了。

```yml
# 默认配置示例
zuul:
  routes:
    autumnnook-system:
      path: /autumnnook-system/**
    autumnnook-menu:
      path: /autumnnook-menu/**
```

也就是说即便我们将路由配置注释掉，同样也能成功访问服务，如下所示。

![image-20251221012543869](assets/image-20251221012543869.png)

到这里为止，我们结合服务名称路由和默认路由的启发，我们可以通过 Eureka 服务注册中心实现动态路由规则并自定义路由 id。需要通过继承 `SimpleRouteLocator` 并实现 `RefreshableRouteLocator` 接口。

- 自定义路由定位器

```java
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.cloud.client.ServiceInstance;
import org.springframework.cloud.client.discovery.DiscoveryClient;
import org.springframework.cloud.netflix.zuul.filters.RefreshableRouteLocator;
import org.springframework.cloud.netflix.zuul.filters.SimpleRouteLocator;
import org.springframework.cloud.netflix.zuul.filters.ZuulProperties;
import org.springframework.util.CollectionUtils;
import javax.annotation.Resource;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.atomic.AtomicInteger;
/**
 * 自定义动态路由定位器，用于从服务注册中心自动发现并创建Zuul路由规则
 * <p>该类继承 {@link SimpleRouteLocator} 并实现 {@link RefreshableRouteLocator} 接口，
 * 提供基于服务发现的路由动态管理能力。当服务在注册中心注册或注销时，路由规则会自动更新。</p>
 * <p><b>主要特性：</b></p>
 * <ul>
 *   <li>自动从服务注册中心发现所有可用服务</li>
 *   <li>为每个服务动态创建统一格式的路由规则</li>
 *   <li>支持路由配置的热刷新，无需重启网关</li>
 *   <li>与静态路由配置共存，动态路由优先</li>
 * </ul>
 * <p><b>使用场景：</b></p>
 * <ul>
 *   <li>微服务架构中服务动态上下线的场景</li>
 *   <li>需要自动为每个注册的服务创建统一路由规则的场景</li>
 *   <li>网关需要实时感知服务注册表变化的场景</li>
 * </ul>
 *
 * @author 蔡熙贝
 * @version 1.0
 * @since 2024
 */
public class SimpleRoutingLocater extends SimpleRouteLocator implements RefreshableRouteLocator {

    /**
     * 日志记录器实例，用于输出路由管理相关的日志信息
     */
    private static final Logger logger = LoggerFactory.getLogger(SimpleRoutingLocater.class);

    /**
     * 路由ID生成器，使用原子操作确保线程安全
     * <p>该生成器为每个动态创建的路由生成唯一标识符，格式为：discovery-{serviceName}-{sequence}</p>
     */
    private static final AtomicInteger ROUTE_ID_GENERATOR = new AtomicInteger(0);

    /**
     * 服务发现客户端，用于从注册中心获取服务信息
     * <p>支持的服务注册中心包括：Eureka、Consul、Nacos等Spring Cloud兼容的注册中心。</p>
     * <p>使用 {@link Resource} 注解实现依赖注入，确保在Spring容器初始化后自动注入。</p>
     */
    @Resource
    private DiscoveryClient discoveryClient;

    /**
     * 构造一个新的动态路由定位器实例
     *
     * @param servletPath 应用上下文路径，用于构建完整路由路径
     * @param properties  Zuul配置属性，包含路由相关的全局设置
     */
    public SimpleRoutingLocater(String servletPath, ZuulProperties properties) {
        super(servletPath, properties);
    }

    /**
     * 刷新路由配置，重新加载所有路由规则
     * <p>该方法会触发路由配置的重新加载过程，通常用于以下场景：</p>
     * <ul>
     *   <li>服务注册表发生变化时</li>
     *   <li>需要强制更新路由缓存时</li>
     *   <li>通过/actuator/refresh端点触发刷新时</li>
     * </ul>
     * <p><b>实现说明：</b>调用父类的{@code doRefresh()}方法重新加载所有路由。</p>
     */
    @Override
    public void refresh() {
        logger.debug("Refreshing zuul routes from discovery client");
        doRefresh();
    }

    /**
     * 定位所有可用的路由规则，包括静态配置和动态发现的路由
     * <p><b>路由加载流程：</b></p>
     * <ol>
     *   <li>首先加载配置文件中的静态路由（通过{@code super.locateRoutes()}）</li>
     *   <li>然后加载从服务发现获取的动态路由（通过{@code locateRoutesFromDiscovery()}）</li>
     *   <li>合并两类路由，动态路由会覆盖同路径的静态路由</li>
     *   <li>记录最终的路由数量和信息</li>
     * </ol>
     *
     * @return 包含所有路由规则的Map，key为路由路径模式，value为对应的路由配置对象
     * @see ZuulProperties.ZuulRoute
     */
    @Override
    protected Map<String, ZuulProperties.ZuulRoute> locateRoutes() {
        Map<String, ZuulProperties.ZuulRoute> routesMap = new LinkedHashMap<>();
        routesMap.putAll(super.locateRoutes());
        routesMap.putAll(locateRoutesFromDiscovery());
        if (logger.isInfoEnabled()) {
            logger.info("Loaded {} zuul routes: {}", routesMap.size(), routesMap.keySet());
        }
        return routesMap;
    }

    /**
     * 从服务发现客户端动态获取并生成路由配置
     * <p><b>处理流程：</b></p>
     * <ol>
     *   <li>获取所有已注册的服务名称列表</li>
     *   <li>检查服务发现是否正常，若无服务则记录警告</li>
     *   <li>遍历每个服务，获取其实例信息</li>
     *   <li>为每个服务创建对应的路由规则</li>
     *   <li>处理重复路由路径的情况</li>
     * </ol>
     * <p><b>异常处理：</b>当服务发现客户端异常时返回空映射，不影响静态路由的正常使用。</p>
     *
     * @return 动态生成的路由配置映射表，key为路由路径，value为路由配置对象
     */
    private Map<String, ZuulProperties.ZuulRoute> locateRoutesFromDiscovery() {
        Map<String, ZuulProperties.ZuulRoute> dynamicRoutes = new LinkedHashMap<>();
        List<String> services = discoveryClient.getServices();
        if (CollectionUtils.isEmpty(services)) {
            logger.warn("No services discovered from discovery client");
            return dynamicRoutes;
        }
        logger.debug("Discovered {} services: {}", services.size(), services);
        for (String serviceName : services) {
            List<ServiceInstance> instances = discoveryClient.getInstances(serviceName);
            if (CollectionUtils.isEmpty(instances)) {
                logger.debug("No instances found for service: {}", serviceName);
                continue;
            }
            ZuulProperties.ZuulRoute route = createRouteForService(serviceName, instances);
            String path = buildRoutePath(serviceName);
            if (!dynamicRoutes.containsKey(path)) {
                dynamicRoutes.put(path, route);
                logger.debug("Created route for service: {} -> {}", path, serviceName);
            } else {
                logger.warn("Duplicate route path detected: {}, skipping", path);
            }
        }
        return dynamicRoutes;
    }

    /**
     * 为指定服务创建路由配置对象
     * <p><b>路由配置详解：</b></p>
     * <ul>
     *   <li><b>id:</b> 路由唯一标识，用于路由管理和监控</li>
     *   <li><b>serviceId:</b> 服务标识，Zuul通过此值进行服务发现和负载均衡</li>
     *   <li><b>retryable:</b> 是否启用重试机制，生产环境建议根据业务需求设置</li>
     *   <li><b>stripPrefix:</b> 是否去除路径前缀，true表示转发时去掉服务名前缀</li>
     *   <li><b>path:</b> 路由匹配路径，用于匹配客户端请求</li>
     * </ul>
     * <p><b>设计考虑：</b>使用serviceId而非直接URL，充分利用Zuul的负载均衡能力。</p>
     *
     * @param serviceName 服务名称，用于设置serviceId和生成路由ID
     * @param instances   服务实例列表，用于记录实例数量信息（调试用）
     * @return 配置完整的Zuul路由对象
     */
    private ZuulProperties.ZuulRoute createRouteForService(String serviceName, List<ServiceInstance> instances) {
        ZuulProperties.ZuulRoute route = new ZuulProperties.ZuulRoute();
        String routeId = generateRouteId(serviceName);
        route.setId(routeId);
        route.setServiceId(serviceName);
        route.setRetryable(false);
        route.setStripPrefix(true);
        route.setPath(buildRoutePath(serviceName));
        if (logger.isDebugEnabled()) {
            logger.debug("Created route: id={}, serviceId={}, path={}, instances={}", routeId, serviceName, route.getPath(),
                instances.size());
        }
        return route;
    }

    /**
     * 生成唯一的路由标识符
     * <p><b>ID格式说明：</b></p>
     * <ul>
     *   <li><b>"discovery":</b> 标识此为动态发现的路由</li>
     *   <li><b>{serviceName}:</b> 关联的服务名称，便于识别</li>
     *   <li><b>{sequence}:</b> 自增序列号，使用{@link AtomicInteger}确保全局唯一性</li>
     * </ul>
     * <p><b>线程安全：</b>使用{@link AtomicInteger}确保并发环境下ID不会冲突。</p>
     *
     * @param serviceName 服务名称，作为ID的一部分
     * @return 格式为"discovery-{serviceName}-{sequence}"的唯一标识符
     */
    private String generateRouteId(String serviceName) {
        return "discovery-" + serviceName + "-" + ROUTE_ID_GENERATOR.incrementAndGet();
    }

    /**
     * 构建路由匹配路径
     * <p><b>路径规则说明：</b></p>
     * <ul>
     *   <li>使用服务名称作为路径前缀</li>
     *   <li>"/**"表示匹配该路径下的所有子路径</li>
     * </ul>
     * <p><b>示例：</b></p>
     * <ul>
     *   <li>服务"user-service"会生成路径"/user-service/**"</li>
     *   <li>请求"/user-service/api/users"会被路由到user-service服务</li>
     *   <li>请求"/user-service/api/orders"也会被路由到user-service服务</li>
     * </ul>
     * <p><b>可扩展性：</b>可根据需要修改路径生成规则，如添加版本前缀"/v1/{serviceName}/**"。</p>
     *
     * @param serviceName 服务名称
     * @return 格式为"/{serviceName}/**"的路由路径
     */
    private String buildRoutePath(String serviceName) {
        return "/" + serviceName + "/**";
    }
}
```

- 添加 Zuul 配置类，替换默认路由定位器，实现基于服务发现的动态路由管理

```java
import com.autumnnook.locator.SimpleRoutingLocater;
import lombok.RequiredArgsConstructor;
import org.springframework.boot.autoconfigure.web.ServerProperties;
import org.springframework.cloud.netflix.zuul.filters.SimpleRouteLocator;
import org.springframework.cloud.netflix.zuul.filters.ZuulProperties;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;
/**
 * Zuul网关配置类
 * <p>该类负责配置Zuul网关的核心组件，特别是自定义路由定位器的注册和初始化。
 * 通过替换默认的路由定位器，实现基于服务发现的动态路由管理。</p>
 * <p><b>主要功能：</b></p>
 * <ul>
 *   <li>配置自定义路由定位器Bean</li>
 *   <li>注入Zuul和服务器相关配置属性</li>
 *   <li>确保自定义路由定位器优先于默认实现</li>
 * </ul>
 * <p><b>配置说明：</b></p>
 * <ul>
 *   <li>使用{@link Configuration}标识为配置类</li>
 *   <li>使用{@link RequiredArgsConstructor}自动生成构造函数</li>
 *   <li>使用{@link Primary}确保自定义Bean优先被使用</li>
 * </ul>
 *
 * @author 蔡熙贝
 * @version 1.0
 * @see SimpleRoutingLocater
 * @see ZuulProperties
 * @see ServerProperties
 * @since 2024
 */
@Configuration
@RequiredArgsConstructor
public class ZuulConfig {

    /**
     * Zuul配置属性，包含路由、过滤器等全局配置
     * <p>该属性通过Spring Boot自动配置注入，包含以下重要配置项：</p>
     * <ul>
     *   <li><b>routes:</b> 静态路由配置</li>
     *   <li><b>prefix:</b> 路由前缀</li>
     *   <li><b>stripPrefix:</b> 是否剥离前缀</li>
     *   <li><b>retryable:</b> 是否可重试</li>
     *   <li><b>sensitiveHeaders:</b> 敏感头信息</li>
     * </ul>
     * <p>这些配置会影响所有路由的行为，包括动态生成的路由。</p>
     */
    private final ZuulProperties zuulProperties;

    /**
     * 服务器配置属性，包含服务器相关的配置信息
     * <p>该属性通过Spring Boot自动配置注入，主要包含：</p>
     * <ul>
     *   <li><b>servlet.context-path:</b> 应用上下文路径</li>
     *   <li><b>server.port:</b> 服务器端口</li>
     *   <li><b>server.address:</b> 服务器地址</li>
     * </ul>
     * <p>上下文路径用于构建完整的前端请求路径，确保路由匹配的正确性。</p>
     */
    private final ServerProperties serverProperties;

    /**
     * 创建并注册自定义路由定位器Bean
     * <p><b>Bean配置说明：</b></p>
     * <ul>
     *   <li>使用{@link Bean}注解将其声明为Spring Bean</li>
     *   <li>使用{@link Primary}注解确保该Bean优先于默认路由定位器</li>
     *   <li>Bean名称为"routeLocator"，与默认实现保持一致</li>
     * </ul>
     * <p><b>参数传递：</b></p>
     * <ul>
     *   <li><b>servletPath:</b> 从{@code serverProperties.getServlet().getContextPath()}获取，
     *       确保路由路径包含正确的上下文前缀</li>
     *   <li><b>zuulProperties:</b> 传递Zuul全局配置，使自定义定位器能够继承默认行为</li>
     * </ul>
     * <p><b>替换机制：</b></p>
     * <p>通过声明同名且标记为{@link Primary}的Bean，Spring容器会优先使用此自定义实现，
     * 从而替换Zuul默认的{@code org.springframework.cloud.netflix.zuul.filters.SimpleRouteLocator}。</p>
     *
     * @return 配置完成的自定义路由定位器实例
     * @see SimpleRoutingLocater#SimpleRoutingLocater(String, ZuulProperties)
     */
    @Bean
    public SimpleRouteLocator routeLocator() {
        return new SimpleRoutingLocater(serverProperties.getServlet().getContextPath(), zuulProperties);
    }
}
```

### 路由排除

我们可以通过路由排除设置不允许被访问的资源，允许被访问的资源可以通过路由规则进行设置。

#### URL 地址排除

```yml
zuul:
  ignored-patterns: /**/order/** # URL 地址排除，排除所有包含 /order/ 的请求不经过 Zuul 处理
  routes:
    autumnnook-system:
      path: /autumnnook-system/**
    autumnnook-menu:
      path: /autumnnook-menu/**
```

#### 服务名称排除

```yaml
zuul:
  ignored-services: autumnnook-test # 忽略的服务列表，避免对特定服务进行路由
  routes:
    autumnnook-system:
      path: /autumnnook-system/**
    autumnnook-menu:
      path: /autumnnook-menu/**
```

### 路由前缀

```yaml
zuul:
  prefix: /api # 全局路由前缀，所有请求路径前添加 /api
  # ignored-services: autumnnook-test # 忽略的服务列表，避免对特定服务进行路由
  # routes:
  #   autumnnook-system:
  #     path: /autumnnook-system/**
  #   autumnnook-menu:
  #     path: /autumnnook-menu/**
```

## 网关过滤器

<img src="assets/image-20251221014048934.png" alt="image-20251221014048934" style="zoom:50%;" />

Zuul 包含了对请求的路由和过滤两个核心功能，其中路由功能负责将外部请求转发到具体的微服务实例上，是实现外部访问统一入口的基础。而过滤器功能则负责对请求的处理过程进行干预，是是实现请求校验，服务聚合等功能的基础。然而实际上，路由功能在真正运行时，他的路由映射和请求转发都是由几个不同的过滤器完成的。

路由映射主要通过 `pre` 类型的过滤器完成，它将请求路径与配置的路由规则进行匹配，以找到需要转发的目标地址。而请求































































































































































