# SpringCloud Ribbon负载均衡

<div style="display:flex;">
    <div style="margin-left:auto;color:#3795f7;"><strong>作者：</strong>蔡熙贝</div>
</div>


## 1.学习目标

<img src="assets/image-20251208162610613.png" alt="image-20251208162610613" style="zoom:80%;" />

## 2.什么是 Ribbon

Ribbon是一个基于HTTP和TCP的客户端负载均衡工具，他是基于 Netflix Ribbon 实现的。它不像 Spring Cloud 服务注册中心，配置中心、API网关那样独立部署，它几乎存在于每个Spring Cloud 微服务中，包括Feign提供的声明式服务调用也是基于 Netfix Ribbon 实现的。

Ribbon默认提供很多种负载均衡算法，比如说： `轮询策略` 、 `随机策略` ...等等。甚至包含自定义的负载均衡算法。

## 3.Ribbon 解决了什么问题

<div style="border: 1px solid #1d63edb5;
    padding: 10px;
    border-left: 5px solid #1d63edb5;
    background: #bed2fa63;
    border-radius: 0 3px 3px 0;
    color: #1d63ed;
    font-family: menlo;
    font-size: 12px;
    margin: 10px 0;
    display: flex;
    align-items: center;
    gap: 8px;">
    <svg viewBox="0 0 24 24" style="flex-shrink: 0;" width="14px" height="14px" fill="none" xmlns="http://www.w3.org/2000/svg" class="MuiSvgIcon-root MuiSvgIcon-colorInfo MuiSvgIcon-fontSizeSmall css-1bqouqa" focusable="false" aria-hidden="true" data-testid="InfoCircleIcon"><path d="M12 16V12M12 8H12.01M22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12Z" stroke="currentColor" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path></svg>
    <span style="line-height: 16px;">Ribbon 提供了一套微服务的负载均衡解决方案。</span>
</div>

负载均衡是在同一应用的不同实例之间分配流量的过程。为了容错，每个应用通常都要运行多个实例。因此，当一个服务需要与另一个服务通信时，它需要选择一个特定的实例来发送请求。负载均衡，有很多算法：

- 随机选择：随机选择一个实例
- 循环：每次按相同顺序选择实例
- 最少连接：选择当前连接最少的实例
- 权重指标：使用权重指标选择最佳实例（例如 CPU 或内存使用率）
- IP 哈希（Hash）：使用客户端 IP 的哈希值映射到实例

以上只是负载均衡算法的几个例子，每种算法都有其优缺点。

随机选择和轮循很容易实现，但可能无法优化服务的使用。相反，最少连接和权重指标比较复杂，但通常能创造更优化的服务利用率。IP 哈希可以保证客户端每次都命中同一台实例，意味着实例可以保存一些客户端的状态信息，但它的容错性不强。

## 4.负载均衡不同方案的区别

目前业界主流的负载均衡方案可分为两类：

- 集中式负载均衡（服务器负载均衡），即在 consumer（消费者）和 provider（服务提供者）之间使用独立的负载均衡设施（可以是硬件，如F5，也可以是软件，如nginx），由该设施负责将访问的请求通过某种策略转发至服务提供者。
- 进程内负载均衡（客户端负载均衡），将负载均衡逻辑集成到consumer（消费者），消费者从服务注册中心获知有哪些地址可用，然后自己再从这些地址种选择一个合适的provider（服务提供者）。<span style="color:#F97A27">Ribbon属于后者，它只是一个类库，集成于消费者进程，消费者通过Ribbon来获取服务提供者的地址。</span>

### 4.1.集中式负载均衡



<img src="./assets/image-20241010154030809.png" alt="image-20241010154030809" style="zoom:77%;" />

### 4.2.进程内负载均衡



<img src="./assets/image-20241010154226336-17285461474291.png" alt="image-20241010154226336" style="zoom:80%;" />

## 5.Ribbon 负载均衡策略

### 5.1.轮询策略（默认）

策略对应类名：<span style="color:#F97A27"> `RoundRobinRule` </span>

实现原理：轮询策略表示每次都顺序取下一个provider，比如有5个provider，第1次取第1个，第2次取第2个，第3次取第3个，依此类推。

### 5.2.权重轮询策略

策略对应类名：<span style="color:#F97A27"> `WeightedResponseTimeRule` </span>

实现原理：

- 根据 provider 的响应时间分配一个权重，响应时间越长，权重越小，被选中的可能性越低；
- 一开始为轮询策略，并开启一个计时器，每30s收集一次每个 provider 的平均响应时长，当信息足够时，给每一个 provider 附上一个权重，并按照权重随机选择 provider ，高权重的 provider 会被高概率选中。

### 5.3.随机策略

策略对应类名：<span style="color:#F97A27"> `RandomRule` </span>

实现原理：从provider中随机选择一个。

### 5.4.最少并发数策略

策略对应类名：<span style="color:#F97A27"> `BestAvailableRule` </span>

实现原理：选择正在请求中的并发数量最小的provider，除非这个provider在熔断中。

### 5.5.重试策略

策略对应类名：<span style="color:#F97A27"> `RetryRule` </span>

实现原理：其实就是轮询策略的增强版，轮询策略在服务不可用时不做处理，重试策略会在服务不可用的时候重新尝试集群中的其他节点。

### 5.6.可用敏感性策略

策略对应类名：<span style="color:#F97A27"> `AvailabilityFilteringRule` </span>

实现原理：过滤性能差的provider。

- 第一种：过滤掉在Eureka中一直处于连接失败的provider。
- 第二种：过滤掉高并发（繁忙）的provider。

### 5.7.区域敏感性策略

策略对应类名：<span style="color:#F97A27"> `ZoneAvoidanceRule` </span>

实现原理：

- 以一个区域为单位考察可用性，对于不可用的区域整个丢弃，从剩下区域中选择可用的provider。
- 如果这个IP区域内有一个或者多个实例不可达 或者 响应变慢，都会降低该IP区域中其他IP被选中的权重。

## 6.Ribbon 入门案例

<div style="border: 1px solid #1d63edb5;
    padding: 10px;
    border-left: 5px solid #1d63edb5;
    background: #bed2fa63;
    border-radius: 0 3px 3px 0;
    color: #1d63ed;
    font-family: menlo;
    font-size: 12px;
    margin: 10px 0;
    display: flex;
    align-items: center;
    gap: 8px;">
    <svg viewBox="0 0 24 24" style="flex-shrink: 0;" width="14px" height="14px" fill="none" xmlns="http://www.w3.org/2000/svg" class="MuiSvgIcon-root MuiSvgIcon-colorInfo MuiSvgIcon-fontSizeSmall css-1bqouqa" focusable="false" aria-hidden="true" data-testid="InfoCircleIcon"><path d="M12 16V12M12 8H12.01M22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12Z" stroke="currentColor" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path></svg>
    <span style="line-height: 16px;">Ribbon 中对于集群中的服务采用的负载均衡策略默认为轮询策略。</span>
</div>

### 6.1.创建项目

还是使用我们在学习Eureka时使用的项目案例，在该项目下面我们继续创建  `bettytsai-system-slave`  模块作为服务提供者，具体项目结构如下：

<img src="./assets/image-20241020125937507-17294003789551.png" alt="image-20241020125937507" style="zoom:80%;" />

应该还记得我们在学习 Eureka 的时候，其实我们就已经写过一个负载均衡的调用案例，只不过那时候我们只是为了去了解服务调用的几种方案，并没有去深入了解负载均衡的几个策略。

### 6.2.服务提供者

创建两个相同的服务提供者是为了模拟分布式多节点部署，所以下面我们就只展示其中一个提供者的配置及代码。

#### 6.2.1.配置文件

```yml
server:
  port: 9000

spring:
  application:
    name: bettytsai-system
  profiles:
    # 以逗号分隔的活动配置文件列表。可由命令行开关覆盖。
    active: dev
  config:
    # 是否启用配置数据处理旧模式
    use-legacy-processing: true

logging:
  file:
    name: ${spring.application.name}-${server.port}
    path: /tlogs/${spring.application.name}
    
eureka:
  client:
    # 指示此客户端是否应从 eureka 服务器获取 eureka 注册表信息。
    fetch-registry: true
    # 指示此实例是否应将其信息注册到 eureka 服务器以供其他人发现。在某些情况下，您不希望发现您的实例，而您只想发现其他实例。
    register-with-eureka: true
    # 指示从 eureka 服务器获取注册表信息的频率（以秒为单位）。
    registry-fetch-interval-seconds: 30
    # 将可用区映射到用于与 eureka 服务器通信的完全限定 URL 列表。
    # 每个值可以是单个 URL 或逗号分隔的备用位置列表。
    # 通常，eureka 服务器 URL 携带协议、主机、端口、上下文和版本信息（如果有）。
    # 示例：https://ec2-256-156-243-129.compute-1.amazonaws.com:7001/eureka/
    # 更改在运行时在 eurekaServiceUrlPollIntervalSeconds 指定的下一个服务 url 刷新周期生效。
    service-url:
      defaultZone: http://admin:123456@127.0.0.1:8761/eureka/,http://admin:123456@127.0.0.1:8762/eureka
  instance:
    # 标志表示，在猜测主机名时，应优先使用服务器的 IP 地址，而不是操作系统报告的主机名。
    prefer-ip-address: true
    # 获取要向 eureka 注册的此实例的唯一 ID（在 appName 范围内）
    instance-id: ${spring.cloud.client.ip-address}:${server.port}
    # 指示 eureka 客户端需要向 eureka 服务器发送心跳以指示它仍然处于活动状态的频率（以秒为单位）。
    # 如果在 leaseExpirationDurationInSeconds 中指定的时间段内未收到心跳，则 eureka 服务器将从其视图中删除该实例，
    # 从而禁止流向此实例的流量。请注意，如果实例实现 HealthCheckCallback，然后决定使自身不可用，则实例仍然无法获取流量。
    lease-renewal-interval-in-seconds: 10
    # 必须与Docker容器名保持一致
    hostname: ${spring.application.name}
```

#### 6.2.2.服务提供者接口

- 服务接口

```java
public interface TestService {

    /**
     * 获取默认标签
     * @return {@link String}
     */
    String getDefaultLabel();
}
```

- 服务实现类

```java
@Service
public class TestServiceImpl implements TestService {
    @Override
    public String getDefaultLabel() {
        return "hello eureka,I'm system master module.";
    }
}
```

- 接口类

```java
@RestController
@RequestMapping(value = "/system/test")
@SuppressWarnings(WarningsConstants.SPRING_JAVA_AUTOWIRED_FIELDS_WARNING_INSPECTION)
public class TestController {

    @Autowired
    private TestService testService;

    @GetMapping(value = "/getDefaultString")
    public String getDefaultString() {
        return testService.getDefaultLabel();
    }
}
```

- 启动类

```java
@Slf4j
@SpringBootApplication
public class SystemMasterApplication {
    public static void main(String[] args) {
        ApplicationContext context = SpringApplication.run(SystemMasterApplication.class, args);
        Environment environment = context.getEnvironment();
        String port = environment.getProperty("server.port");
        log.info(String.format(":::系统启动成功....端口号::: %s",port));
    }
}
```

#### 6.2.3.启动服务

启动两个服务提供者之后，我们打开注册中心，可以看到服务提供者以集群模式部署了两个节点。

<img src="./assets/image-20241020151603695.png" alt="image-20241020151603695" style="zoom:100%;" />

### 6.3.服务消费者

#### 6.3.1.配置文件

```yml
server:
  port: 9002

spring:
  application:
    name: bettytsai-test
  profiles:
    # 以逗号分隔的活动配置文件列表。可由命令行开关覆盖。
    active: dev
  config:
    # 是否启用配置数据处理旧模式
    use-legacy-processing: true

logging:
  file:
    name: ${spring.application.name}-${server.port}
    path: /tlogs/${spring.application.name}

eureka:
  client:
    # 指示此客户端是否应从 eureka 服务器获取 eureka 注册表信息。
    fetch-registry: true
    # 指示此实例是否应将其信息注册到 eureka 服务器以供其他人发现。在某些情况下，您不希望发现您的实例，而您只想发现其他实例。
    register-with-eureka: true
    # 指示从 eureka 服务器获取注册表信息的频率（以秒为单位）。
    registry-fetch-interval-seconds: 30
    # 将可用区映射到用于与 eureka 服务器通信的完全限定 URL 列表。
    # 每个值可以是单个 URL 或逗号分隔的备用位置列表。
    # 通常，eureka 服务器 URL 携带协议、主机、端口、上下文和版本信息（如果有）。
    # 示例：https://ec2-256-156-243-129.compute-1.amazonaws.com:7001/eureka/
    # 更改在运行时在 eurekaServiceUrlPollIntervalSeconds 指定的下一个服务 url 刷新周期生效。
    service-url:
      defaultZone: http://admin:123456@127.0.0.1:8761/eureka/,http://admin:123456@127.0.0.1:8762/eureka
  instance:
    # 标志表示，在猜测主机名时，应优先使用服务器的 IP 地址，而不是操作系统报告的主机名。
    prefer-ip-address: true
    # 获取要向 eureka 注册的此实例的唯一 ID（在 appName 范围内）
    instance-id: ${spring.cloud.client.ip-address}:${server.port}
    # 指示 eureka 客户端需要向 eureka 服务器发送心跳以指示它仍然处于活动状态的频率（以秒为单位）。
    # 如果在 leaseExpirationDurationInSeconds 中指定的时间段内未收到心跳，则 eureka 服务器将从其视图中删除该实例，
    # 从而禁止流向此实例的流量。请注意，如果实例实现 HealthCheckCallback，然后决定使自身不可用，则实例仍然无法获取流量。
    lease-renewal-interval-in-seconds: 10
    # 必须与Docker容器名保持一致
    hostname: ${spring.application.name}
```

#### 6.3.2.服务消费者接口

- 接口类

```java
@Slf4j
@RestController
@RequestMapping(value = "/test/test")
@SuppressWarnings(WarningsConstants.SPRING_JAVA_AUTOWIRED_FIELDS_WARNING_INSPECTION)
public class DemoController {

    @Autowired
    private RestTemplate restTemplate;

    @Autowired
    private LoadBalancerClient loadBalancerClient;
    
    @GetMapping(value = "/test2")
    public String getTest2() {
        // 根据服务名称获取服务
        String serviceName = "bettytsai-system";
        ServiceInstance instance = loadBalancerClient.choose(serviceName);
        ExceptionUtil.throwException(ObjectUtil.isNull(instance),"获取服务实例失败!");
        // 调用服务接口，ResponseEntity封装了返回数据
        String url = "http://" + instance.getHost() + ":" + instance.getPort() + "/system/test/getDefaultString";
        log.info("服务调用地址::: {}",url);
        ResponseEntity<String> response = restTemplate.exchange(url, HttpMethod.GET, null,
                new ParameterizedTypeReference<String>() {}
        );
        return response.getBody();
    }
}
```

- 配置类

我们通过  `LoadBalancerClient`  类实现服务的远程调用，不使用  `@LoadBalanced`  负载均衡注解，这样我们可以很直观的看到所调用的服务地址，方便我们验证。

```java
@Configuration
public class RestConfig {
    @Bean
    public RestTemplate restTemplate(){
        return new RestTemplate();
    }
}
```

#### 6.3.3.启动服务

我们通过多次访问接口 http://127.0.0.1:9002/test/test/test2 进行测试，可以看到控制台输出内容如下所示，由此可见，默认是采用的轮询策略。

![image-20241020154224743](./assets/image-20241020154224743-17294101484113.png)

## 7.Ribbon 负载均衡策略设置

在上一节中，我们通过入门案例了解到默认的负载均衡策略就是轮询策略，那么这一节中，我们就来看看如何调整负载均衡策略。

### 7.1.全局设置

<div style="border: 1px solid rgba(255, 165, 0,.1);
    padding: 10px;
    border-left: 5px solid rgba(255, 165, 0);
    background: rgba(255, 165, 0,.1);
    border-radius: 0 3px 3px 0;
    color: rgba(255, 165, 0);
    font-family: menlo;
    font-size: 12px;
    margin: 10px 0;
    display: flex;
    align-items: center;
    gap: 8px;">
    <svg viewBox="0 0 24 24" width="14px" height="14px" fill="none" style="flex-shrink: 0;" xmlns="http://www.w3.org/2000/svg">
    <path d="M12 8.00008V12.0001M12 16.0001H12.01M3 7.94153V16.0586C3 16.4013 3 16.5726 3.05048 16.7254C3.09515 16.8606 3.16816 16.9847 3.26463 17.0893C3.37369 17.2077 3.52345 17.2909 3.82297 17.4573L11.223 21.5684C11.5066 21.726 11.6484 21.8047 11.7985 21.8356C11.9315 21.863 12.0685 21.863 12.2015 21.8356C12.3516 21.8047 12.4934 21.726 12.777 21.5684L20.177 17.4573C20.4766 17.2909 20.6263 17.2077 20.7354 17.0893C20.8318 16.9847 20.9049 16.8606 20.9495 16.7254C21 16.5726 21 16.4013 21 16.0586V7.94153C21 7.59889 21 7.42756 20.9495 7.27477C20.9049 7.13959 20.8318 7.01551 20.7354 6.91082C20.6263 6.79248 20.4766 6.70928 20.177 6.54288L12.777 2.43177C12.4934 2.27421 12.3516 2.19543 12.2015 2.16454C12.0685 2.13721 11.9315 2.13721 11.7985 2.16454C11.6484 2.19543 11.5066 2.27421 11.223 2.43177L3.82297 6.54288C3.52345 6.70928 3.37369 6.79248 3.26463 6.91082C3.16816 7.01551 3.09515 7.13959 3.05048 7.27477C3 7.42756 3 7.59889 3 7.94153Z" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
    </path>
</svg>
    <span style="line-height: 16px;">Spring Cloud 2020 版本以后，默认移除了对 Netflix 的依赖，其中就包括 Ribbon，官方默认推荐使用 Spring Cloud Loadbalancer 正式替换 Ribbon，并成为了 Spring Cloud 负载均衡器的唯一实现。</span>
</div>
这里为了学习 Ribbon 负载均衡，所以我们还是统一将版本设置为 <span style="color:rgba(247, 167, 184)">Spring Cloud 2020.0.0</span> 之前的版本：

```xml
<properties>
	<!--...其他组件版本版本号不展示-->
    <spring-boot.version>2.3.3.RELEASE</spring-boot.version>
    <spring-cloud.version>Hoxton.SR12</spring-cloud.version>
    <spring-cloud-alibaba.version>2.2.7.RELEASE</spring-cloud-alibaba.version>
</properties>
```

然后在启动类或者配置类中注入负载均衡策略对象。所有服务请求均使用该策略。

```java
@Bean
public IRule randomRule(){
    IRule rule;
    // 轮询策略（默认）
    rule = new RoundRobinRule();
    // 随机策略
    // rule = new RandomRule();
    // 权重轮询策略
    // rule = new WeightedResponseTimeRule();
    // 最少并发策略
    // rule = new BestAvailableRule();
    // 重试策略
    // rule = new RetryRule();
    // 可用敏感性策略
    // rule = new AvailabilityFilteringRule();
    // 区域敏感性策略
    // rule = new ZoneAvoidanceRule();
    return rule;
}
```

启动我们的消费者服务，我们通过多次访问接口 http://127.0.0.1:9002/test/test/test2 进行测试，可以看到控制台输出内容如下所示，由此可见，默认是采用的随机策略。

![image-20241022145002537](./assets/image-20241022145002537-17295798042602.png)

### 7.2.局部设置

删除全局配置，然后修改配置文件，指定所调用的某一个服务的负载均衡策略。格式：<span style="color:#FEA60B">服务应用名.ribbon.NFLoadBalancerRuleClassName</span> 

```yml
# 负载均衡策略
# bettytsai-system 为所调用的服务名称
bettytsai-system:
  ribbon:
    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule
```

启动我们的消费者服务，我们通过多次访问接口 http://127.0.0.1:9002/test/test/test2 进行测试，可以看到控制台输出内容如下所示，由此可见，默认是采用的随机策略。

![image-20241022145847573](./assets/image-20241022145847573-17295803295373.png)

## 8.Ribbon 点对点直连

<div style="border: 1px solid #1d63edb5;
    padding: 10px;
    border-left: 5px solid #1d63edb5;
    background: #bed2fa63;
    border-radius: 0 3px 3px 0;
    color: #1d63ed;
    font-family: menlo;
    font-size: 12px;
    margin: 10px 0;
    display: flex;
    align-items: center;
    gap: 8px;">
    <svg viewBox="0 0 24 24" style="flex-shrink: 0;" width="14px" height="14px" fill="none" xmlns="http://www.w3.org/2000/svg" class="MuiSvgIcon-root MuiSvgIcon-colorInfo MuiSvgIcon-fontSizeSmall css-1bqouqa" focusable="false" aria-hidden="true" data-testid="InfoCircleIcon"><path d="M12 16V12M12 8H12.01M22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12Z" stroke="currentColor" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path></svg>
    <span style="line-height: 16px;">Ribbon 点对点直连是指绕过注册中心，直接连接服务提供者获取服务，一般在测试阶段使用比较多。</span>
</div>

### 8.1.添加依赖

要使用点对点直连，那么我们需要消费者剔除 Eureka 依赖及相关配置之后，添加 Ribbon依赖。

```xml
<!-- 剔除Eureka依赖 -->
<!--<dependency>
	<groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
</dependency>-->
<!-- 添加Ribbon依赖 -->
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-ribbon</artifactId>
</dependency>
```

### 8.2.配置直连

配置文件中关闭 Eureka ，添加直连服务地址。如果不设置负载均衡策略默认使用轮询策略。

```yaml
# bettytsai-system 为所调用的服务名称
bettytsai-system:
  ribbon:
    # 负载均衡策略
    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule
    # 指定具体的服务列表，多个以,分隔
    listOfServers: http://127.0.0.1:9000/,http://127.0.0.1:9001/

# 关闭eureka，实现点对点直连
ribbon:
  eureka:
    enabled: false
```

然后我们只启动服务提供者和服务消费者，不启动注册中心，可能会看到服务提供者连接注册中心报错，但是服务是可正常消费的，我们只不过是通过点对点直连方式调用。多次访问接口 http://127.0.0.1:9002/test/test/test2 进行测试，可以看到控制台输出内容如下所示，实现了点对点直连。

![image-20241022161931476](./assets/image-20241022161931476-17295851725934.png)

## 9.LoadBalancer负载均衡器

### 9.1.为什么要学习 Spring Cloud Balancer?

随着微服务架构越来越流行，在不同服务器上运行多个服务变得越来越普遍。Ribbon 作为早期的客户端负载均衡工具，在 Spring Cloud 2020.0.0 版本之后已经被移除了，取而代之的是 Spring Cloud LoadBalancer，而且 Ribbon 也已经不再维护，所以它也是 Spring 官方推荐的负载均衡解决方案。

Spring Cloud Balancer还有着一些其他的优势：

- 更好的兼容性：LoadBalancer就像一个全新的配件，它与Spring Cloud的其他组件搭配得更好。

- 支持响应式编程：现在编程界有一种新的编程方式叫做“响应式编程”，LoadBalancer能很好地支持这种现代编程风格。
- 易于使用和维护：LoadBalancer的设计易于拼装和修改，这对于开发者来说，维护和定制起来更加方便。

- 多功能：LoadBalancer有很多内置功能，比如自动帮你挑选服务器，就像购物网站帮你推荐商品一样聪明。

### 9.2.添加依赖

配置文件中引入loadbalancer依赖，如果是微服务项目，请跳过该步骤。可以将  `spring.cloud.loadbalancer.enabled`  的值设置为  `false`  以禁用 Spring Cloud LoadBalancer 。

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-loadbalancer</artifactId>
    <version>xxx.xx.xx</version>
</dependency>
```

### 9.3.启用负载均衡

```java
@Bean
@LoadBalanced  // 启用负载均衡
public RestTemplate restTemplate(){
    return new RestTemplate();
}

// 或者，如果使用 WebClient
// @Bean
// @LoadBalanced
// public WebClient.Builder loadBalancedWebClientBuilder() {  
//     return WebClient.builder().filter(new LoadBalancerClientFilter());  
// }  
```

### 9.4.服务调用

服务调用还是同我们在Eureka学习中一样，使用<span style="color:#F3AD61;"> RestTemplate</span> 进行服务的调用，如下所示。

```java
public class DemoController {

    @Autowired
    private RestTemplate restTemplate;
    
    @GetMapping(value = "/test3")
    public String getTest() {
        String serviceName = "bettytsai-system";
        String url = "http://" + serviceName + "/system/test/getDefaultString";
        ResponseEntity<String> response = restTemplate.exchange(url, HttpMethod.GET, null,new ParameterizedTypeReference<String>(){});
        log.info("服务调用结果::: {}",response.getBody());
        return response.getBody();
    }
}
```

依次启动注册中心、服务提供者和服务消费者，多次访问接口 http://127.0.0.1:9002/test/test/test2 进行测试，可以看到控制台输出内容如下所示，由此可见，默认是采用的随机策略。

![image-20241023225841147](./assets/image-20241023225841147.png)

### 9.5.在负载均衡算法之间切换

默认使用的  `ReactiveLoadBalancer`  实现是  `RoundRobinLoadBalancer` （轮询策略） 。如果要切换到其他实现，无论是针对所选服务还是所有服务，您可以使用[自定义 LoadBalancer 配置机制](https://docs.spring.io/spring-cloud-commons/docs/3.1.8/reference/html/#custom-loadbalancer-configuration)。

比如说，下面的配置可以通过  `@LoadBalancerClient`  注解来切换到  `RandomLoadBalancer` （随机策略）。

```java
public class CustomLoadBalancerConfiguration {
    @Bean
    ReactorLoadBalancer<ServiceInstance> randomLoadBalancer(Environment environment,
            LoadBalancerClientFactory loadBalancerClientFactory) {
        String name = environment.getProperty(LoadBalancerClientFactory.PROPERTY_NAME);
        return new RandomLoadBalancer(loadBalancerClientFactory
                .getLazyProvider(name, ServiceInstanceListSupplier.class),
                name);
    }
}
```

<div style="border: 1px solid rgba(254, 40, 87,.1);
    padding: 10px;
    border-left: 5px solid rgba(254, 40, 87);
    background: rgba(254, 40, 87,.1);
    border-radius: 0 3px 3px 0;
    color:rgba(254, 40, 87);
    font-family: menlo;
    font-size: 12px;
    margin: 10px 0;
    display: flex;
    align-items: center;
    gap: 8px;">
    <svg viewBox="0 0 24 24" style="flex-shrink: 0;" width="14px" height="14px" fill="none" xmlns="http://www.w3.org/2000/svg" class="MuiSvgIcon-root MuiSvgIcon-fontSizeSmall css-8l52ux" focusable="false" aria-hidden="true" data-testid="ErrorIcon"><path d="M12 8.00008V12.0001M12 16.0001H12.01M3 7.94153V16.0586C3 16.4013 3 16.5726 3.05048 16.7254C3.09515 16.8606 3.16816 16.9847 3.26463 17.0893C3.37369 17.2077 3.52345 17.2909 3.82297 17.4573L11.223 21.5684C11.5066 21.726 11.6484 21.8047 11.7985 21.8356C11.9315 21.863 12.0685 21.863 12.2015 21.8356C12.3516 21.8047 12.4934 21.726 12.777 21.5684L20.177 17.4573C20.4766 17.2909 20.6263 17.2077 20.7354 17.0893C20.8318 16.9847 20.9049 16.8606 20.9495 16.7254C21 16.5726 21 16.4013 21 16.0586V7.94153C21 7.59889 21 7.42756 20.9495 7.27477C20.9049 7.13959 20.8318 7.01551 20.7354 6.91082C20.6263 6.79248 20.4766 6.70928 20.177 6.54288L12.777 2.43177C12.4934 2.27421 12.3516 2.19543 12.2015 2.16454C12.0685 2.13721 11.9315 2.13721 11.7985 2.16454C11.6484 2.19543 11.5066 2.27421 11.223 2.43177L3.82297 6.54288C3.52345 6.70928 3.37369 6.79248 3.26463 6.91082C3.16816 7.01551 3.09515 7.13959 3.05048 7.27477C3 7.42756 3 7.59889 3 7.94153Z" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path></svg>
    <span style="line-height: 12px;">作为 @LoadBalancerClient 、 @LoadBalancerClients 注解的配置参数传递的类不应被 @Configuration 注解所标注，更不应该超出组件的扫描范围。</span>
</div>

具体什么意思呢？你可能看到这句话有点迷惑，直接看看示例代码：

```java
import org.springframework.cloud.client.ServiceInstance;
import org.springframework.cloud.loadbalancer.core.RandomLoadBalancer;
import org.springframework.cloud.loadbalancer.core.ReactorLoadBalancer;
import org.springframework.cloud.loadbalancer.core.ServiceInstanceListSupplier;
import org.springframework.cloud.loadbalancer.support.LoadBalancerClientFactory;
import org.springframework.context.annotation.Bean;
import org.springframework.core.env.Environment;
// 这里不能使用 @Configuration 进行标注！！
public class LoadBalancerConfig {
    @Bean
    public ReactorLoadBalancer<ServiceInstance> randomLoadBalancer(Environment environment,LoadBalancerClientFactory loadBalancerClientFactory) {
        String name = environment.getProperty(LoadBalancerClientFactory.PROPERTY_NAME);
        return new RandomLoadBalancer(loadBalancerClientFactory.getLazyProvider(name, ServiceInstanceListSupplier.class), name);
    }
}
```

```java
@Configuration
// 上面的类作为 @LoadBalancerClient 注解的配置参数进行传递~
@LoadBalancerClients({@LoadBalancerClient(value = "bettytsai-system", configuration = LoadBalancerConfig.class)})
public class RestTemplateConfig {
    @Bean
    @LoadBalanced
    public RestTemplate restTemplate() {
        return new RestTemplate();
    }
}
```

大概就是这个意思。现在我们再来多次访问接口 http://127.0.0.1:9002/test/test/test2 进行测试，可以看到控制台输出内容如下所示。

![image-20241023231650756](./assets/image-20241023231650756.png)

可见，负载均衡算法现在就是随机算法了。
