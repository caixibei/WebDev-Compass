# Spring Cloud Eureka 集群部署

<div style="display:flex;">
    <div style="margin-left:auto;color:#3795f7;"><strong>作者：</strong>蔡熙贝</div>
</div>

## 环境准备

为了少踩坑，所以我还是大致说下我的开发环境吧。

- java 1.8.0_152
- docker 26.1.4
- idea 2023.2
- maven 3.6.3
- git 2.26.2

因为我本机配置不够高，跑 Docker Desktop 就会很卡顿，所以我的 Docker 是放在华为云服务器上部署的。

## 创建项目

<div style="border: 1px solid #1d63edb5;
    padding: 10px;
    border-left: 5px solid #1d63edb5;
    background: #bed2fa63;
    border-radius: 0 3px 3px 0;
    color: #1d63ed;
    font-family: menlo;
    font-size: 12px;
    margin: 10px 0;
    display: flex;
    align-items: center;
    gap: 8px;">
    <svg viewBox="0 0 24 24" style="flex-shrink: 0;" width="14px" height="14px" fill="none" xmlns="http://www.w3.org/2000/svg" class="MuiSvgIcon-root MuiSvgIcon-colorInfo MuiSvgIcon-fontSizeSmall css-1bqouqa" focusable="false" aria-hidden="true" data-testid="InfoCircleIcon"><path d="M12 16V12M12 8H12.01M22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12Z" stroke="currentColor" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path></svg>
    <span style="line-height: 16px;">你可以选择直接使用 IDEA 去创建项目骨架，甚至你使用 Eclipse 搭建都行，但我都不用。</span>
</div>

访问 <span style="color:#4185C6;">start.spring.io</span> 或者 <span style="color:#4185C6;">start.aliyun.com</span> 站点地址，搭建微服务项目骨架，我这里选择使用阿里云提供的，具体如下图所示：

![image-20241226153343989](./assets/image-20241226153343989.png)

点击获取代码之后，将代码下载下来，最终我们的项目结构应该如下所示：

![image-20241226160248870](./assets/image-20241226160248870.png)

## 项目托管

我们选择将代码托管到 “全球最大的同性交友网站” ，创建仓库，具体如下：

![image-20241226154149306](./assets/image-20241226154149306.png)



创建好仓库之后，我们需要进行仓库认证才可以往上推代码，接下来我们就是进行认证，打开 Git 命令控制台，配置账户和邮箱：

```bash
git config –global user.name '<账户名>'
git config –global user.email '<邮箱>'
```

打开 Git 命令控制台，生成密钥：

```bash
#-t 指定密钥类型，默认是 rsa ，可以省略。
#-C 设置注释文字，比如邮箱。
#-f 指定密钥文件存储文件名。
ssh-keygen -t rsa -C '<邮箱>'
```

输入完成后，连续按3个回车，密钥生成结果如下：

```bash
[root@localhost ~]# ssh-keygen -t rsa       <== 建立密钥对，-t代表类型，有RSA和DSA两种
Generating public/private rsa key pair.
Enter file in which to save the key (/root/.ssh/id_rsa):   <==密钥文件默认存放位置，按Enter即可
Created directory '/root/.ssh'.
Enter passphrase (empty for no passphrase):     <== 输入密钥锁码，或直接按 Enter 留空
Enter same passphrase again:     <== 再输入一遍密钥锁码
Your identification has been saved in /root/.ssh/id_rsa.    <== 生成的私钥
Your public key has been saved in /root/.ssh/id_rsa.pub.    <== 生成的公钥
The key fingerprint is:
SHA256:K1qy928tkk1FUuzQtlZK+poeS67vIgPvHw9lQ+KNuZ4 root@localhost.localdomain
The key's randomart image is:
+---[RSA 2048]----+
|           +.    |
|          o * .  |
|        . .O +   |
|       . *. *    |
|        S =+     |
|    .    =...    |
|    .oo =+o+     |
|     ==o+B*o.    |
|    oo.=EXO.     |
+----[SHA256]-----+
```

最后在 `.ssh` 目录下得到了两个文件： `id_rsa` （私钥）和 `id_rsa.pub` （公钥），路径上面的输出结果有，你也可以通过： `cmd+R` ，输入  `%userprofile%` 进入：

![image-20241226155105010](./assets/image-20241226155105010.png)

将  `rsa.pub`  中的密钥复制到剪贴板中（备用），然后打开 Github，进入设置 （Settings）中，如下所示（我开了翻译插件）：

![image-20241226154457244](./assets/image-20241226154457244.png)

然后将公钥粘贴进新建的 SSH密钥里面，如下图所示：

![image-20241226155533514](./assets/image-20241226155533514.png)

最后，打开 Git Bash命令控制台，验证是否连接成功：

```bash
ssh -T git@github.com
```

结果如下：

```bash
$ ssh -T git@github.com
Hi xxxx! You've successfully authenticated, but GitHub does not provide shell access.
```

打开仓库页面复制仓库地址，如下所示：

![image-20241226155857493](./assets/image-20241226155857493.png)

切记，不是  `HTTPS`  协议的地址 ，然后将我们的项目推送至仓库即可。

## 依赖管理

父项目  `pom`  依赖管理，具体版本配置如下： 

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <packaging>pom</packaging>
    <description>Tsai Spring Cloud</description>
    <groupId>tsai.spring.cloud</groupId>
    <artifactId>tsai-spring-cloud</artifactId>
    <version>1.1.0</version>

    <properties>
        <java.version>1.8</java.version>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
        <maven.compiler.version>3.8.1</maven.compiler.version>
        <spring-boot.version>2.7.6</spring-boot.version>
        <spring-cloud.version>2021.0.5</spring-cloud.version>
        <spring-cloud-alibaba.version>2021.0.5.0</spring-cloud-alibaba.version>
        <inject.version>1</inject.version>
    </properties>

    <modules>
        <module>spring-cloud-eureka</module>
    </modules>

    <dependencyManagement>
        <dependencies>
            <!-- spring boot -->
            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-dependencies</artifactId>
                <version>${spring-boot.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
            <!--spring cloud-->
            <dependency>
                <groupId>org.springframework.cloud</groupId>
                <artifactId>spring-cloud-dependencies</artifactId>
                <version>${spring-cloud.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
            <!--spring cloud alibaba-->
            <dependency>
                <groupId>com.alibaba.cloud</groupId>
                <artifactId>spring-cloud-alibaba-dependencies</artifactId>
                <version>${spring-cloud-alibaba.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
            <!-- inject -->
            <dependency>
                <groupId>javax.inject</groupId>
                <artifactId>javax.inject</artifactId>
                <version>${inject.version}</version>
            </dependency>
        </dependencies>
    </dependencyManagement>

    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>${maven.compiler.version}</version>
                <configuration>
                    <source>${java.version}</source>
                    <target>${java.version}</target>
                    <encoding>${project.build.sourceEncoding}</encoding>
                    <verbose>false</verbose>
                    <showWarnings>false</showWarnings>
                    <fork>true</fork>
                    <compilerVersion>1.5</compilerVersion>
                    <meminitial>512m</meminitial>
                    <maxmem>2048m</maxmem>
                </configuration>
            </plugin>
        </plugins>
    </build>

</project>
```

注册中心  `pom`  依赖配置如下：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <parent>
        <groupId>tsai.spring.cloud</groupId>
        <artifactId>tsai-spring-cloud</artifactId>
        <version>1.1.0</version>
    </parent>

    <modelVersion>4.0.0</modelVersion>
    <artifactId>spring-cloud-eureka</artifactId>

    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-logging</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-security</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <version>${spring-boot.version}</version>
                <configuration>
                    <fork>true</fork>
                    <excludes>
                        <exclude>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok</artifactId>
                        </exclude>
                    </excludes>
                    <includeSystemScope>true</includeSystemScope>
                </configuration>
                <executions>
                    <execution>
                        <goals>
                            <goal>repackage</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>
        </plugins>
    </build>

</project>
```

## 注册中心配置

注册中心上下文配置如下，因为后续我们需要通过 docker 一键部署到服务器，所以参数动态可选，如不配置，以默认值为准：

```yaml
server:
  port: ${SERVER_PORT:8761}

spring:
  application:
    name: ${APPLICATION_NAME:spring-cloud-eureka}
  # eureka 相关配置
  security:
    user:
      name: ${EUREKA_ADMIN_NAME:eureka}
      password: ${EUREKA_ADMIN_PASSWORD:eureka}

# eureka 相关配置
eureka:
  server:
    enable-self-preservation: true
    eviction-interval-timer-in-ms: 30000
  instance:
    hostname: ${HOSTNAME:${spring.application.name}}
    prefer-ip-address: ${PREFER_IP_ADDRESS:false}
    instance-id: ${spring.cloud.client.ip-address}:${server.port}
  client:
    fetch-registry: ${FETCH_REGISTRY:false}
    register-with-eureka: ${REGISTER_WITH_EUREKA:false}
    service-url:
      defaultZone: ${DEFAULT_ZONE:http://${spring.security.user.name}:${spring.security.user.password}@${eureka.instance.hostname}:8761/eureka/}

# actuator 相关配置
management:
  endpoints:
    web:
      exposure:
        include: ${ENDPOINTS:info,shutdown}
  endpoint:
    shutdown:
      enabled: ${ENABLE_SHOWDOWN:false}
```

在这里我们还是用到了安全认证，所以我们要添加安全认证配置类，不然注册中心无法注册服务：

```java
@Configuration
@EnableWebSecurity
public class WebSecurityConfig extends WebSecurityConfigurerAdapter {
    @Override
    public void configure(HttpSecurity http) throws Exception {
        super.configure(http);
        http.csrf().ignoringAntMatchers("/eureka/**");
    }
}
```

开启日志记录，添加日志配置文件  `logback-spring.xml` ，内容如下：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
    <!--引入默认配置-->
    <include resource="org/springframework/boot/logging/logback/defaults.xml"/>
    <property scope="context" name="log.path" value="/logs/"/>
    <springProperty scope="context" name="log.name" source="spring.application.name"/>

    <!-- 控制台输出配置 -->
    <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <pattern>${CONSOLE_LOG_PATTERN}</pattern>
        </encoder>
        <!-- 只输出DEBUG级别及以上的日志 -->
        <filter class="ch.qos.logback.classic.filter.ThresholdFilter">
            <level>DEBUG</level>
        </filter>
    </appender>

    <!-- 文件输出配置 -->
    <appender name="INFO_FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>${log.path}/${log.name}.info.log</file>
        <encoder>
            <pattern>${CONSOLE_LOG_PATTERN}</pattern>
        </encoder>
        <!-- 只输出INFO级别的日志 -->
        <filter class="ch.qos.logback.classic.filter.LevelFilter">
            <level>INFO</level>
            <onMatch>ACCEPT</onMatch>
            <onMismatch>DENY</onMismatch>
        </filter>
        <rollingPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy">
            <fileNamePattern>${log.path}/%d{yyyy-MM-dd}/${log.name}.info.%d{yyyy-MM-dd}-%i.log</fileNamePattern>
            <!-- 每个文件最大2MB -->
            <maxFileSize>2MB</maxFileSize>
            <!-- 最多保留30天的历史记录 -->
            <maxHistory>30</maxHistory>
        </rollingPolicy>
    </appender>

    <!-- 文件输出配置 -->
    <appender name="ERROR_FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>${log.path}/${log.name}.error.log</file>
        <encoder>
            <pattern>${CONSOLE_LOG_PATTERN}</pattern>
        </encoder>
        <!-- 只输出ERROR级别的日志 -->
        <filter class="ch.qos.logback.classic.filter.LevelFilter">
            <level>ERROR</level>
            <onMatch>ACCEPT</onMatch>
            <onMismatch>DENY</onMismatch>
        </filter>
        <rollingPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy">
            <fileNamePattern>${log.path}/%d{yyyy-MM-dd}/${log.name}.error.%d{yyyy-MM-dd}-%i.log</fileNamePattern>
            <!-- 每个文件最大2MB -->
            <maxFileSize>2MB</maxFileSize>
            <!-- 最多保留30天的历史记录 -->
            <maxHistory>30</maxHistory>
        </rollingPolicy>
    </appender>

    <appender name="WARNING_FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>${log.path}/${log.name}.warning.log</file>
        <encoder>
            <pattern>${CONSOLE_LOG_PATTERN}</pattern>
        </encoder>
        <filter class="ch.qos.logback.classic.filter.LevelFilter">
            <level>WARN</level>
            <onMatch>ACCEPT</onMatch>
            <onMismatch>DENY</onMismatch>
        </filter>
        <rollingPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy">
            <fileNamePattern>${log.path}/%d{yyyy-MM-dd}/${log.name}.warning.%d{yyyy-MM-dd}-%i.log</fileNamePattern>
            <maxFileSize>2MB</maxFileSize>
            <maxHistory>30</maxHistory>
        </rollingPolicy>
    </appender>

    <root level="INFO">
        <appender-ref ref="STDOUT"/>
        <appender-ref ref="INFO_FILE"/>
        <appender-ref ref="ERROR_FILE"/>
        <appender-ref ref="WARNING_FILE"/>
    </root>
</configuration>
```

启动类编写，输出一些启动信息，方便我们排查：

```java
@EnableEurekaServer
@SpringBootApplication
public class EurekaServerApplication {
    
    private static Logger logger = LoggerFactory.getLogger(EurekaServerApplication.class);

    public static void main(String[] args) {
        ApplicationContext context = SpringApplication.run(EurekaServerApplication.class, args);
        Environment environment = context.getEnvironment();
        String port = environment.getProperty("server.port");
        String fetchRegistry = environment.getProperty("eureka.client.fetch-registry");
        String registryWithEureka = environment.getProperty("eureka.client.register-with-eureka");
        String defaultZone = environment.getProperty("eureka.client.service-url.defaultZone");
        String hostname = environment.getProperty("eureka.instance.hostname");
        String preferIpAddress = environment.getProperty("eureka.instance.prefer-ip-address");
        logger.info("===================注册中心运行环境信息===================");
        logger.info("服务端口：{}",port);
        logger.info("实例地址：{}",hostname);
        logger.info("是否从注册中心拉取服务：{}", fetchRegistry);
        logger.info("是否注册到注册中心：{}", registryWithEureka);
        logger.info("注册中心集群地址：{}", defaultZone);
        logger.info("是否优先使用服务器的IP地址：{}", preferIpAddress);
        logger.info("=======================================================");
    }
}
```

最后，启动注册中心服务，以默认配置启动，验证服务是否可用即可。

## 集群部署

编写  `Dockerfile`  文件，具体内容如下：

```dockerfile
# 基于java镜像创建新镜像
FROM openjdk:8
# 作者
MAINTAINER caixibei
# 将jar包添加到容器中并更名为 mvn 打包后的jar包名
# 在target目录下找得到
ADD  target/spring-cloud-eureka-1.1.0.jar spring-cloud-eureka-1.1.0.jar
# 运行jar包
ENTRYPOINT ["java","-jar","/spring-cloud-eureka-1.1.0.jar","&"]

# 暴露端口
# EXPOSE 8761
```

打开 IDEA 设置，搜索 SSH ，如下所示，添加我们的远端服务器连接配置：

![image-20241226161616345](./assets/image-20241226161616345.png)

填写完服务器信息之后，点击测试连接，具体如下：

![image-20241226161718325](./assets/image-20241226161718325.png)

接下来需要配置连接Docker守护进程 `（File->Settings->搜索docker）` 来操作Docker，具体如下所示：

![image-20241226161857209](./assets/image-20241226161857209.png)

然后我们就需要配置远程部署环境了，具体操作示意图如下：

![image-20241226162003510](./assets/image-20241226162003510.png)

新建配置，因为我要部署2个注册中心，所以我配置两个，这样后续就不需要修改参数。

![image-20241226162139252](./assets/image-20241226162139252.png)

配置部署参数，这个在上面的上下文配置中找对应的 键名：

![image-20241226162619143](./assets/image-20241226162619143.png)

最终生成的  `docker run`  命令如下：

```shell
docker build -f Dockerfile \
-t spring-cloud-eureka:1.1.1 . \
&& docker run -p 8761:8761 \
--env APPLICATION_NAME=spring-cloud-eureka \
--env DEFAULT_ZONE=http://eureka:eureka@116.205.112.132:8762/eureka/ \
--env FETCH_REGISTRY=true \
--env HOSTNAME=spring-cloud-eureka-8761 \
--env REGISTER_WITH_EUREKA=true \
--env SERVER_PORT=8761 \
--env PREFER_IP_ADDRESS=true \
--name spring-cloud-eureka-8761 \
--restart always \
--net host \
spring-cloud-eureka:1.1.1 
```

最终配置结果图如下：

![image-20241226162537984](./assets/image-20241226162537984.png)

然后点击 部署 运行即可：

![image-20241226162926540](./assets/image-20241226162926540.png)

在控制台也能看到运行的日志，十分方便：

![image-20241226163019826](./assets/image-20241226163019826.png)